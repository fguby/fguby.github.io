{
    "version": "https://jsonfeed.org/version/1",
    "title": "(๑•̀ㅂ•́)و✧",
    "subtitle": "人间情事一丢，就有了清澈的骨骼",
    "icon": "https://fguby.love/images/favicon.ico",
    "description": "懒、宅、二次元、萝莉控",
    "home_page_url": "https://fguby.love",
    "items": [
        {
            "id": "https://fguby.love/Golang/",
            "url": "https://fguby.love/Golang/",
            "title": "Go Scheduler",
            "date_published": "2020-12-26T17:29:25.000Z",
            "content_html": "<p>对 Go 调度器的学习总结，涉及系统调度、Goroutine 模型<br />\n<a id=\"more\"></a></p>\n<h2 id=\"os-scheduler\"><a class=\"anchor\" href=\"#os-scheduler\">#</a> OS Scheduler</h2>\n<p>从操作系统角度看，程序最终都会转换成一系列的机器指令，机器只要按顺序执行完所有的指令就算完成了任务。</p>\n<p>完成 “按顺序执行指令” 任务的实体就是线程，也就是说，线程是 CPU 调度的实体，是真正在 CPU 上执行指令的实体。</p>\n<h2 id=\"线程切换\"><a class=\"anchor\" href=\"#线程切换\">#</a> 线程切换</h2>\n<p>OS Scheduler 调度线程的依据就是它的状态，线程的三种状态：</p>\n<ul>\n<li>Waiting 等待状态，线程在等待某件事的发生，例如等待网络数据、硬盘；调用操作系统 API；等待内存同步访问条件 ready，如 atomic，mutexes</li>\n<li>Runnable 就绪状态，只要给 CPU 资源就能运行</li>\n<li>Executing 运行状态</li>\n</ul>\n<h2 id=\"什么是goroutine\"><a class=\"anchor\" href=\"#什么是goroutine\">#</a> 什么是 goroutine</h2>\n<p>Goroutine 可以看作是对线程加的一层抽象，它更轻量级，可以单独执行，不是 OS 线程，也不是绿色线程（由语言的运行时管理的线程）。</p>\n<h2 id=\"goroutine和thread的区别\"><a class=\"anchor\" href=\"#goroutine和thread的区别\">#</a> goroutine 和 thread 的区别</h2>\n<p>可以从三个角度区别：内存消耗、创建与销毁、切换</p>\n<ul>\n<li>内存占用<br />\n创建一个 goroutine 的栈内存消耗为 2KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。<br />\n创建一个 thread 则需要消耗 1MB 栈内存。</li>\n<li>创建和销毁<br />\n Thread 创建和销毁都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的销毁非常小，是用户级。</li>\n<li>切换<br />\n线程切换的时候，需要保存各种寄存器，以便将来恢复，goroutine 的切换只需要保存三个寄存器：PC, SP, BP。</li>\n</ul>\n<h2 id=\"mn模型\"><a class=\"anchor\" href=\"#mn模型\">#</a> M:N 模型</h2>\n<p>Go runtime 会负责 Goroutine 的生老病死，从创建到销毁，都一手包办。</p>\n<p>Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行。</p>\n<p>在同一时刻，一个线程上只能跑一个 goroutine，当 goroutine 发生阻塞时，runtime 会把当前的 goroutine 调度走，让其他 goroutine 来执行。</p>\n<h2 id=\"scheduler\"><a class=\"anchor\" href=\"#scheduler\">#</a> Scheduler</h2>\n<p>Runtime 维护所有的 goroutines，并通过 scheduler 来进行调度。</p>\n<p>有三个基础的结构体来实现 goroutines 的调度。</p>\n<p>::G::：代表一个 goroutine<br />\n::M::：表示内核线程，包含正在运行的 goroutine 等字段<br />\n:😛::：代表 g 执行的上下文环境，它维护一个处于 Runable 状态的 G 队列，M 需要获得 P 才能运行 G。</p>\n<p><img data-src=\"http://www.midoriya.co/uPic/1*QaG177Xaz7hHBaJSxSDjBA.png\" alt=\"avatar\" /></p>\n<p>每个 Goroutine 在 OS 线程上（M）运行。</p>\n<p>Runtime 在运行时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一个 M 用来开始 G 的运行，随着时间推移，更多的 G 会被创建出来，更多的 M 也会被创建出来。</p>\n<p>GO Scheduler 的核心思想就是:</p>\n<ol>\n<li>reuse threads;（复用线程）</li>\n<li>限制同时运行的线程数为 N，N 等于 CPU 的核心数目；（N 可以由 GOMAXPROCS 变量来决定）</li>\n<li>线程私有的 runqueues，并且可以从其他线程 stealing goroutine 来运行，线程阻塞后，可以将 runqueues 传递给其他线程。</li>\n</ol>\n<p>Go 程序启动后，会给每个逻辑核心分配一个 P，同时会给每个 P 分配一个 M，内核线程依然由 OS Scheduler 来调度。</p>\n<h2 id=\"具体流程\"><a class=\"anchor\" href=\"#具体流程\">#</a> 具体流程</h2>\n<p>假设一段代码如下：</p>\n<pre><code>func main() &#123;\n   var wg sync.WaitGroup\n   wg.Add(2)\n\n   go func() &#123;\n      println(`hello`)\n      wg.Done()\n   &#125;()\n\n   go func() &#123;\n      println(`world`)\n      wg.Done()\n   &#125;()\n\n   wg.Wait()\n&#125;\n</code></pre>\n<p>Go 首先会根据逻辑 CPU 核心数创建不同的 P，并且将这些 P 存储在一个空闲的 P 列表中。</p>\n<p><img data-src=\"http://www.midoriya.co/uPic/1*R8hPBHK-8aultosys9D8tQ.png\" alt=\"avatar\" /></p>\n<p>接下来，当有新的 Goroutine 或者是准备运行的 Goroutine 将唤醒 P 以更好地分配工作。</p>\n<p>这个 P 将创建一个关联的 M（系统线程）：<br />\n<img data-src=\"http://www.midoriya.co/uPic/1*CCguz8qrjngfk98HlTpcYA.png\" alt=\"1*CCguz8qrjngfk98HlTpcYA\" /></p>\n<p>当遇到以下情况时 P 又会重新回到上面的空闲列表中：</p>\n<ul>\n<li>没有 Goroutine 准备或是等待运行</li>\n<li>从系统调用中返回</li>\n<li>被垃圾收集器停止（也就是所谓的 STW，stop the world）</li>\n</ul>\n<p>在程序的启动期间，Go 已经创建了一些 OS 线程和相关的 M。</p>\n<h3 id=\"系统调用\"><a class=\"anchor\" href=\"#系统调用\">#</a> 系统调用</h3>\n<p>Go 通过将它们包装在 runtime 中来优化系统调用（无论是否阻塞），这个包装器将自动从线程 M 上分离出 P 并且允许另一个线程来运行它。<br />\n以读取文件为例：</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> main（）<span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   buf：<span class=\"token operator\">=</span> <span class=\"token builtin\">make</span>（<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token builtin\">byte</span>，<span class=\"token number\">0</span>，<span class=\"token number\">2</span>）</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   fd，<span class=\"token boolean\">_</span>：<span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>Open（“number<span class=\"token punctuation\">.</span>txt”）</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   fd<span class=\"token punctuation\">.</span>Read（buf）</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   fd<span class=\"token punctuation\">.</span>Close（）</pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token builtin\">println</span>（<span class=\"token builtin\">string</span>（buf<span class=\"token punctuation\">)</span>）<span class=\"token comment\">// 42 </span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>以下是打开文件时的工作流程：</p>\n<p><img data-src=\"http://www.midoriya.co/uPic/1*l56efREv5Exm21lzNeKt_w.png\" alt=\"1*l56efREv5Exm21lzNeKt_w\" /></p>\n<p>当主协程中执行 os.Open () 函数时，线程 M0 进入阻塞状态，p0 回到空闲列表中并且处于可运行状态。</p>\n<p>然后，当系统调用退出，Go 就会应用以下规则，直到可以满足：</p>\n<ul>\n<li>试图获得完全一样的 P，p0 在空闲列表中，可以继续执行</li>\n<li>尝试在空闲列表中获取一个 p 执行</li>\n<li>把 Goroutine 放到全局可运行队列中，并且将 M 放回空闲列表中</li>\n</ul>\n<p>但是在非阻塞 IO（例如 http 调用）的情况下，Go 还可以处理资源尚未准备就绪的情况。在这种情况下，由于资源尚未准备就绪，Go 将使用网络轮询器将 Goroutine 停放。</p>\n<figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t\thttp<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token string\">`https://httpstat.us/200`</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>一旦完成第一个系统调用并明确资源尚未准备就绪，goroutine 将驻留，直到网络轮询器通知，在这种情况下，线程 M 将不会被阻塞。</p>\n<p>Go 调度程序查找后，线程 M 将会运行另外一个 Goroutine。</p>\n<p>如果准备了多个 goroutine，则多余的 goroutine 将进入全局可运行队列，并在以后进行调度。</p>\n<h2 id=\"grq和lrq\"><a class=\"anchor\" href=\"#grq和lrq\">#</a> GRQ 和 LRQ</h2>\n<p>全局可运行队列 (GRQ) 以及本地可运行队列 (LRQ)</p>\n<p>LRQ 存储本地（也就是具体的 p）的可运行 goroutine， GRQ 存储全局的可运行 goroutine，这些 goroutine 还没有分配到具体的 p。</p>\n<h2 id=\"g0\"><a class=\"anchor\" href=\"#g0\">#</a> g0</h2>\n<p>Go 使用::GOMAXPROCS:: 环境变量来限制同时运行的 OS 线程数，这意味着 Go 必须在每个运行的线程上调度和管理 Goroutine，该角色委托给了一个特殊的 Goroutine，也就是::g0::，这是为每个 OS 线程创建的第一个 Goroutine。</p>\n<p><img data-src=\"http://www.midoriya.co/uPic/1*NK13K84tQhVx8DCPSXNG_g.png\" alt=\"1*NK13K84tQhVx8DCPSXNG_g\" /></p>\n<p>随后，g0 将安排就绪的 Goroutine 在线程上运行。</p>\n<h3 id=\"g0的职责\"><a class=\"anchor\" href=\"#g0的职责\">#</a> g0 的职责</h3>\n<p>和普通的 Goroutine 相反，g0 具有确定的和更大的堆栈。<br />\n它的职责包括：</p>\n<ul>\n<li>Goroutine 创建，使用 go 关键字的时候，Go 会将函数创建委托到 g0，然后将创建的 Goroutine 放置到本地队列中</li>\n<li>延迟功能分配</li>\n<li>垃圾收集器操作，例如 STW，扫描 goroutine 的堆栈以及一些标记和清除操作</li>\n<li>堆栈增长，在需要时，Go 会增加 goroutine 的大小，该操作也会通过 g0 来完成</li>\n</ul>\n<p>这种特殊的 goroutine 还涉及到许多其他操作（大分配，cgo 等）。</p>\n<h2 id=\"goroutine调度代价\"><a class=\"anchor\" href=\"#goroutine调度代价\">#</a> goroutine 调度代价</h2>\n<p>在 Go 中，一个 goroutine 的切换确实很轻量级，为了保存 goroutine，它只需要完成两件事：</p>\n<ul>\n<li>goroutine 在未调度之前停止的行，也就是保存当前要运行的行到 PC 寄存器中，稍后 goroutine 将在相同的地方恢复运行。</li>\n<li>goroutine 的堆栈，以便在再次运行时还原局部变量。</li>\n</ul>\n<p>假设有一段这样的代码：<br />\n<img data-src=\"http://www.midoriya.co/uPic/1*TZobNBH4mKyaN8B_ru7tUA.png\" alt=\"1*TZobNBH4mKyaN8B_ru7tUA\" /><br />\n 消费者会打印从 0 到 99 的偶数。</p>\n<p>首先，关注一下第一个 goroutine（生产者），它将数字添加到 channel 的缓冲区中，当缓冲区被填满，当它再次发送数据时将会被阻塞。这个时候，Go 将会切换到 g0 并且调度另外一个 goroutine。</p>\n<p>Go 首先需要保存当前指令，以便在同一条指令中恢复 goroutine，PC 保存在 goroutine 的内部结构中，示例图如下。</p>\n<p><img data-src=\"http://www.midoriya.co/uPic/1*ArVyzi31WBefg4RhhX5Pdw.png\" alt=\"1*ArVyzi31WBefg4RhhX5Pdw\" /></p>\n<p>指令以及地址可以使用以下命令查找:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>go tool objdump</pre></td></tr></table></figure><p><img data-src=\"http://www.midoriya.co/uPic/9888D7A2-E02B-4A9C-8897-A81A760F7247.png\" alt=\"9888D7A2-E02B-4A9C-8897-A81A760F7247\" /></p>\n<p><img data-src=\"http://www.midoriya.co/uPic/1*E9HFNIw4ZhDirUh4dgWbsw.png\" alt=\"1*E9HFNIw4ZhDirUh4dgWbsw\" /></p>\n<p>在通道阻塞之前（runtime.chansend1），程序逐步执行指令，Go 保存当前的 PC 寄存器为当前 goroutine 的一个内部属性.<br />\n 在上图的例子中，Go 通过内存地址 <code>0x4268d0</code>  保存 PC 寄存器，它在 runtime 和函数 runtime.chansend1 的内部。</p>\n<p><img data-src=\"http://www.midoriya.co/uPic/1*i1SaUH3K7pjijTtW-O1TKw.png\" alt=\"1*i1SaUH3K7pjijTtW-O1TKw\" /></p>\n<p>接下来，当 g0 唤醒 goroutine，它将恢复到相同的指令处，执行循环，将值传入通道。</p>\n<h2 id=\"goroutine调度期间的堆栈管理\"><a class=\"anchor\" href=\"#goroutine调度期间的堆栈管理\">#</a> goroutine 调度期间的堆栈管理</h2>\n<p>在被阻塞之前，正在运行的 goroutine 具有原来的堆栈，这个堆栈包含临时的内存，例如变量 <code>i</code> ：</p>\n<p><img data-src=\"http://www.midoriya.co/uPic/1*8oa7ziZBpHZqKVihpQ3b8g.png\" alt=\"1*8oa7ziZBpHZqKVihpQ3b8g\" /></p>\n<p>然后，当它在 channel 上被阻塞的时候，goroutine 以及堆栈都将被切换成 g0 以及 g0 的堆栈，一个更大的堆栈，如图。</p>\n<p><img data-src=\"http://www.midoriya.co/uPic/1*I42dKDU2BV6kTwWMWiA1JQ.png\" alt=\"1*I42dKDU2BV6kTwWMWiA1JQ\" /></p>\n<p>在切换之前，这个堆栈将被保存起来用以 goroutine 再次运行时恢复。<br />\n<img data-src=\"http://www.midoriya.co/uPic/1*kmufEth8mfd7OLnkl9oC7Q.png\" alt=\"1*kmufEth8mfd7OLnkl9oC7Q\" /></p>\n<p>需要注意的是，一些架构例如 arm，需要保存更多的寄存器：LR（连接寄存器）。</p>\n<h2 id=\"goroutine切换总结\"><a class=\"anchor\" href=\"#goroutine切换总结\">#</a> goroutine 切换总结</h2>\n<p>以上图中的 channel 为例：</p>\n<ul>\n<li>当 goroutine 在 channel 上阻塞并且切换到了 g0\n<ol>\n<li>PC 寄存器与堆栈指针一起保存到内部结构中</li>\n<li>g0 被设置为运行协程</li>\n<li>g0 的堆栈替换当前堆栈</li>\n</ol>\n</li>\n<li>g0 正在寻找新的 goroutine 运行</li>\n<li>g0 必须使用选定的 goroutine 进行切换：\n<ol>\n<li>从内部结构中提取出 PC 寄存器和堆栈指针</li>\n<li>程序跳转到从 PC 中提取出来的地址</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"goroutine调度时机\"><a class=\"anchor\" href=\"#goroutine调度时机\">#</a> goroutine 调度时机</h2>\n<ul>\n<li>使用关键字 go<br />\n 创建一个新的 goroutine，Go Scheduler 会考虑调度。<br />\n:: 新创建的 Goroutine 优先运行，并放置在 LRQ 的顶部::</li>\n<li>GC<br />\n 由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。</li>\n<li>系统调用<br />\n当 goroutine 进行系统调用时，会阻塞 M，所以它会被调度走，同时一个新的 goroutine 会被调度上来</li>\n<li>内存同步访问<br />\n atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。</li>\n</ul>\n<p>此外，需要注意，在调度期间，LRQ（本地队列）具有优先级。</p>\n<h2 id=\"work-stealing\"><a class=\"anchor\" href=\"#work-stealing\">#</a> work stealing</h2>\n<p>Go Scheduler 的职责就是将所有处于 Runnable 的 goroutines 均匀分布到在 p 上运行的 M。</p>\n<p>当 P 的 LRQ 里没有 goroutine 时，它会先去全局队列里（GRQ）和网络轮询器中查看，如果这两者都为空，它将从其他 P 那里窃取 goroutine。</p>\n<p>TODO</p>\n<h2 id=\"参考文章\"><a class=\"anchor\" href=\"#参考文章\">#</a> 参考文章</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYXJkYW5sYWJzLmNvbS9ibG9nLzIwMTgvMTIvc2NoZWR1bGluZy1pbi1nby1wYXJ0My5odG1s\">Scheduling In Go : Part III - Concurrency</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWdvcm91dGluZS1vcy10aHJlYWQtYW5kLWNwdS1tYW5hZ2VtZW50LTJmNWE1ZWFmNTE4YQ==\">Go: Goroutine, OS Thread and CPU Management - A Journey With Go - Medium</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWcwLXNwZWNpYWwtZ29yb3V0aW5lLThjNzc4YzY3MDRkOA==\">Go: g0, Special Goroutine - A Journey With Go - Medium</span></p>\n",
            "tags": [
                "Golang",
                "Scheduler"
            ]
        },
        {
            "id": "https://fguby.love/beautify-blog/",
            "url": "https://fguby.love/beautify-blog/",
            "title": "美化系列小记：Hexo博客",
            "date_published": "2020-12-26T17:29:25.000Z",
            "content_html": "<p>古话说过，工欲善其事必先利其器。这句话其实说的还蛮有道理的，作为一个颜值党，无论是 IDE 还是博客，甚至是操作系统，都需要一定程度的美化，至少赏心悦目才能吃得下去饭吧。</p>\n<p>本篇是美化系列小记的第一篇，如何美化自己的博客。<br />\n<a id=\"more\"></a></p>\n<h2 id=\"博客框架\"><a class=\"anchor\" href=\"#博客框架\">#</a> 博客框架</h2>\n<p>我用过 Hexo 和 Hugo，就个人而言，可能 Hexo 目前更好用一些，毕竟主题丰富，尽管 Hugo 号称构建网站最快的框架，但是在主题和插件的支持上目前还比不上 Hexo。</p>\n<p>Hexo 的基本使用参考官网即可，这里就不描述了。</p>\n<h2 id=\"选取主题\"><a class=\"anchor\" href=\"#选取主题\">#</a> 选取主题</h2>\n<p>在 Hexo 官网的主题页面或者是 github 里，你能搜到一大把好看的主题，只要选择自己心仪的那一个即可，一般主题的作者也都会在 README.md 里添上详细的安装教程，当然基本都大同小异。</p>\n<ol>\n<li>\n<p><code>git clone 主题库</code></p>\n</li>\n<li>\n<p>将主题放入到 theme 里即可，然后修改 <code>_config.yaml</code></p>\n</li>\n<li>\n<p>添加主题特有的配置</p>\n</li>\n</ol>\n<h2 id=\"评论系统\"><a class=\"anchor\" href=\"#评论系统\">#</a> 评论系统</h2>\n<p>以我的博客举例，使用的是 valine。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly92YWxpbmUuanMub3JnL3F1aWNrc3RhcnQuaHRtbA==\">参考这篇教程</span></p>\n<p>使用起来还是很简单、方便 的，基本上注册完填写对应 App ID 和 App Key 就行了，在主题里的配置基本也都差不多，例如：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">valine</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">appId</span><span class=\"token punctuation\">:</span> xxxx</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">appKey</span><span class=\"token punctuation\">:</span> xxxx</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">placeholder</span><span class=\"token punctuation\">:</span> ヽ(○´∀`)ﾉ♪ <span class=\"token comment\"># Comment box placeholder</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token key atrule\">avatar</span><span class=\"token punctuation\">:</span> mp <span class=\"token comment\"># Gravatar style : mp, identicon, monsterid, wavatar, robohash, retro</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token key atrule\">pageSize</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span> <span class=\"token comment\"># Pagination size</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token key atrule\">lang</span><span class=\"token punctuation\">:</span> en</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token key atrule\">visitor</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span> <span class=\"token comment\"># Article reading statistic</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token key atrule\">NoRecordIP</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span> <span class=\"token comment\"># Whether to record the commenter IP</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token key atrule\">serverURLs</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token key atrule\">powerMode</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token key atrule\">tagMeta</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token key atrule\">visitor</span><span class=\"token punctuation\">:</span> 孤荡的灵魂</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token key atrule\">master</span><span class=\"token punctuation\">:</span> 主人</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token key atrule\">friend</span><span class=\"token punctuation\">:</span> 基友们</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token key atrule\">investor</span><span class=\"token punctuation\">:</span> 土豪</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token key atrule\">tagColor</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token key atrule\">master</span><span class=\"token punctuation\">:</span> <span class=\"token important\">&amp;quot;var(--color-orange)&amp;quot;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token key atrule\">friend</span><span class=\"token punctuation\">:</span> <span class=\"token important\">&amp;quot;var(--color-aqua)&amp;quot;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token key atrule\">investor</span><span class=\"token punctuation\">:</span> <span class=\"token important\">&amp;quot;var(--color-pink)&amp;quot;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token key atrule\">tagMember</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token key atrule\">master</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>      <span class=\"token comment\"># - hash of master@email.com</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>      <span class=\"token comment\"># - hash of master2@email.com</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token key atrule\">friend</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>      <span class=\"token comment\"># - hash of friend@email.com</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>      <span class=\"token comment\"># - hash of friend2@email.com</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token key atrule\">investor</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>      <span class=\"token comment\"># - hash of investor1@email.com</span></pre></td></tr></table></figure><h2 id=\"搜索功能-algolia\"><a class=\"anchor\" href=\"#搜索功能-algolia\">#</a> 搜索功能 - algolia</h2>\n<p>建站的时候摸索了一会儿 algolia 的使用办法，在这里记录下。如果你选择的博客主题也使用了 algolia，那么可以参考下。</p>\n<ol>\n<li>\n<p>首先也是注册账号，注册完以后在界面左部的菜单栏找到 API Keys 一栏，点击后你就能看到自己的 Application ID 等必要信息。</p>\n</li>\n<li>\n<p>新建一个用来搜索的 index，博客的数据到时候也会上传到这里。</p>\n</li>\n<li>\n<p>在 API Keys 界面里新建一个 API Key（点击第一个红框圈住的按钮），在添加的界面里<strong> Indices</strong> 中选择步骤 2 里新建的 index，然后在<strong> ACL</strong> 一栏中选中 <code>listIndexes</code> ， <code>deleteObject</code> ， <code>addObject</code></p>\n</li>\n</ol>\n<p><img data-src=\"http://www.midoriya.co/example1227-1.png\" alt=\"avatar\" title=\"示例一\" /></p>\n<ol start=\"4\">\n<li>\n<p>之后在示例的截图中红框圈住的部分就会生成一个 API Keys。</p>\n</li>\n<li>\n<p>安装 algolia 插件。</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> --save hexo-algolia</pre></td></tr></table></figure><ol start=\"6\">\n<li>步骤 4 中得到的 API Keys 就是单独的 API 密钥，执行如下命令。</li>\n</ol>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">HEXO_ALGOLIA_INDEXING_KEY</span><span class=\"token operator\">=</span>API密钥</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>./node_modules/.bin/hexo algolia</pre></td></tr></table></figure><ol start=\"7\">\n<li>End</li>\n</ol>\n<h2 id=\"live2d看板娘\"><a class=\"anchor\" href=\"#live2d看板娘\">#</a> live2D 看板娘</h2>\n<p>如果想配置 live2D 看板娘在你的博客上，也很简单，hexo 有现成的插件，直接安装即可使用。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJk\">插件的 github 地址</span></p>\n<ol>\n<li>安装模块</li>\n</ol>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> --save hexo-helper-live2d</pre></td></tr></table></figure><ol start=\"2\">\n<li>参照 Example，这里贴下我的配置</li>\n</ol>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">live2d</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">enable</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\">#enable: false</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">scriptFrom</span><span class=\"token punctuation\">:</span> local <span class=\"token comment\"># 默认</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token key atrule\">pluginRootPath</span><span class=\"token punctuation\">:</span> live2dw/ <span class=\"token comment\"># 插件在站点上的根目录 (相对路径)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token key atrule\">pluginJsPath</span><span class=\"token punctuation\">:</span> lib/ <span class=\"token comment\"># 脚本文件相对与插件根目录路径</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token key atrule\">pluginModelPath</span><span class=\"token punctuation\">:</span> assets/ <span class=\"token comment\"># 模型文件相对与插件根目录路径</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token comment\"># scriptFrom: jsdelivr # jsdelivr CDN</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token comment\"># scriptFrom: unpkg # unpkg CDN</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token comment\"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token key atrule\">tagMode</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span> <span class=\"token comment\"># 标签模式，是否仅替换 live2d tag 标签而非插入到所有页面中</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token key atrule\">debug</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span> <span class=\"token comment\"># 调试，是否在控制台输出日志</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token key atrule\">model</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token key atrule\">use</span><span class=\"token punctuation\">:</span> rem</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token key atrule\">scale</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1.7</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token key atrule\">hHeadPos</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0.5</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token key atrule\">vHeadPos</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0.618</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\"># use: live2d-widget-model-wanko # npm-module package name</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token comment\"># use: wanko # 博客根目录 /live2d_models/ 下的目录名</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\"># use: ./wives/wanko # 相对于博客根目录的路径</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>  <span class=\"token key atrule\">display</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token key atrule\">position</span><span class=\"token punctuation\">:</span> right</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token key atrule\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">200</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token key atrule\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">360</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>  <span class=\"token key atrule\">mobile</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token key atrule\">show</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span> <span class=\"token comment\"># 是否在移动设备上显示</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token key atrule\">scale</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1.5</span> <span class=\"token comment\"># 移动设备上的缩放</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>  <span class=\"token key atrule\">react</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token key atrule\">opacityDefault</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0.7</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token key atrule\">opacityOnHover</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0.2</span></pre></td></tr></table></figure><p>模型可以自己去找，我使用的是雷姆和小埋的模型，如果你也想要的话，可以联系我。</p>\n<p>目前暂时就写这么多。</p>\n<p>未完待续......</p>\n",
            "tags": [
                "工具",
                "美化"
            ]
        }
    ]
}