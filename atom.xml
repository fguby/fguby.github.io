<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Midoriya</title>
  
  
  <link href="https://www.midoriya.com/atom.xml" rel="self"/>
  
  <link href="https://www.midoriya.com/"/>
  <updated>2021-02-15T07:15:03.136Z</updated>
  <id>https://www.midoriya.com/</id>
  
  <author>
    <name>我妻善逸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>热补丁之旅（五）Ptrace</title>
    <link href="https://www.midoriya.com/hotpatch-5/"/>
    <id>https://www.midoriya.com/hotpatch-5/</id>
    <published>2021-02-14T14:29:25.000Z</published>
    <updated>2021-02-15T07:15:03.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>先准备一个示例程序,该程序每隔3s就调用一次<code>print_msg()</code>函数，现在我们将尝试在进程不停止的情况下，将程序的调用函数修改为<code>print_msg1()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_msg</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_msg1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_msg();</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;patch before\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_msg1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;patch success!!!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>Linux提供了<code>Ptrace</code>函数可以附加到某一进程上，读取/修改该进程的内存，这一节也将使用这个函数来实现修改函数的跳转。</p><p>大致逻辑：</p><ol><li>找到<code>print_msg()</code>和<code>print_msg1()</code>两个函数的虚拟内存地址</li><li>在<code>print_msg()</code>函数内写入跳转指令，让其跳转到<code>print_msg1()</code>函数</li></ol><p>定义一个结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Progress <span class="keyword">struct</span> &#123;</span><br><span class="line">Pid     <span class="keyword">int</span>    <span class="comment">/* 进程pid */</span></span><br><span class="line">ExeName <span class="keyword">string</span> <span class="comment">/* 二进制文件名称 */</span></span><br><span class="line">WorkDir <span class="keyword">string</span> <span class="comment">/* 进程的工作目录 */</span></span><br><span class="line">MapData []<span class="keyword">byte</span> <span class="comment">/* /proc/pid/maps数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="proc-pid-maps"><a href="#proc-pid-maps" class="headerlink" title="/proc/pid/maps"></a><code>/proc/pid/maps</code></h2><p>根据前面几节的内容，我们知道可以通过<code>符号表</code>来获取函数的偏移地址，但是光有偏移地址还不够，还需要知道ELF文件映射到内存中的起始地址。</p><p>这个时候，可以读取<code>/proc/pid/maps</code>文件来获取我们所需要的地址，例如下图中的地址<code>55fa5bf1a000</code></p><p><img src= "/img/giphy.gif" data-lazy-src="/img/maps.png" alt="maps"></p><h2 id="proc-pid-comm"><a href="#proc-pid-comm" class="headerlink" title="/proc/pid/comm"></a><code>/proc/pid/comm</code></h2><p>通过读取该文件获取二进制所对应的文件名称</p><h2 id="pwdx-pid"><a href="#pwdx-pid" class="headerlink" title="pwdx pid"></a><code>pwdx pid</code></h2><p>通过该命令来获取进程对应的工作目录</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="初始化Progress"><a href="#初始化Progress" class="headerlink" title="初始化Progress"></a>初始化<code>Progress</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProgress</span><span class="params">(pid <span class="keyword">int</span>)</span> *<span class="title">Progress</span></span> &#123;</span><br><span class="line">p := &amp;Progress&#123;</span><br><span class="line">Pid: pid,</span><br><span class="line">&#125;</span><br><span class="line">exeName, err := p.getExeName()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">p.ExeName = <span class="keyword">string</span>(exeName)</span><br><span class="line">p.ExeName = strings.Replace(p.ExeName, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">p.WorkDir = p.getWorkDir()</span><br><span class="line">p.MapData = p.getMapData()</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取-proc-pid-comm"><a href="#读取-proc-pid-comm" class="headerlink" title="读取/proc/pid/comm"></a>读取<code>/proc/pid/comm</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetExeName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Progress)</span> <span class="title">getExeName</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">b, err := ioutil.ReadFile(fmt.Sprintf(<span class="string">&quot;/proc/%d/comm&quot;</span>, p.Pid))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取进程的工作目录"><a href="#读取进程的工作目录" class="headerlink" title="读取进程的工作目录"></a>读取进程的工作目录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Progress)</span> <span class="title">getWorkDir</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, fmt.Sprintf(<span class="string">&quot;pwdx %d&quot;</span>, p.Pid))</span><br><span class="line">output, err := cmd.CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">dir := strings.Split(<span class="keyword">string</span>(output), <span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">dir = strings.Replace(dir, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">dir = strings.TrimSpace(dir)</span><br><span class="line"><span class="keyword">return</span> dir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取-proc-pid-maps"><a href="#读取-proc-pid-maps" class="headerlink" title="读取/proc/pid/maps"></a>读取<code>/proc/pid/maps</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Progress)</span> <span class="title">getMapData</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">mapdata, err := ioutil.ReadFile(fmt.Sprintf(<span class="string">&quot;/proc/%d/maps&quot;</span>, p.Pid))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapdata</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="获取进程的首地址"><a href="#获取进程的首地址" class="headerlink" title="获取进程的首地址"></a>获取进程的首地址</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// FindStartAddr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Progress)</span> <span class="title">FindStartAddr</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">lines := strings.Split(<span class="keyword">string</span>(p.MapData), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">addr := strings.Split(lines[<span class="number">0</span>], <span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">start := strings.Split(addr, <span class="string">&quot;-&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">c, err := strconv.ParseUint(start, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取指定函数的内存地址"><a href="#获取指定函数的内存地址" class="headerlink" title="获取指定函数的内存地址"></a>获取指定函数的内存地址</h3><p>该函数依赖于ELF文件解析完成，即上一节中实现的<code>Open函数</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(elf *ElfFile)</span> <span class="title">FindFuncAddr</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">uint64</span>, <span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line">symbols, err := elf.getType(SHT_SYMTAB)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr <span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">var</span> size <span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">for</span> _, symbol := <span class="keyword">range</span> symbols &#123;</span><br><span class="line"><span class="keyword">if</span> symbol.NameStr == name &#123;</span><br><span class="line">addr = symbol.Value</span><br><span class="line">size = symbol.Size</span><br><span class="line"></span><br><span class="line">elf.Seek(<span class="keyword">int64</span>(symbol.Value), seekStart)</span><br><span class="line"></span><br><span class="line">code := <span class="built_in">make</span>([]<span class="keyword">byte</span>, symbol.Size)</span><br><span class="line"><span class="keyword">if</span> _, err := io.ReadFull(elf.SectionReader, code); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr, size, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>这里为了方便测试，直接将进程的pid写死。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pid = <span class="number">31100</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">syscall.PtraceDetach(pid)</span><br><span class="line">log.Fatal(err)</span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造一个progress</span></span><br><span class="line">p := trace.NewProgress(pid)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取elf文件的全路径</span></span><br><span class="line">exe := path.Join(p.WorkDir, p.ExeName)</span><br><span class="line">    <span class="comment">// 封装了下上一节的解析器，调用Open函数</span></span><br><span class="line">elfFile, err := elfobject.Open(exe)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 获取print_msg的函数地址</span></span><br><span class="line">addr1, _, err := elfFile.FindFuncAddr(<span class="string">&quot;print_msg&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 获取print_msg1的函数地址</span></span><br><span class="line">addr2, _, err := elfFile.FindFuncAddr(<span class="string">&quot;print_msg1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转指令</span></span><br><span class="line">jmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>)</span><br><span class="line">jmp[<span class="number">0</span>] = <span class="number">0xE9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算print_msg1函数距print_msg的偏移地址</span></span><br><span class="line">offset := addr2 - (addr1 + <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该地址转成四字节的bytes数组</span></span><br><span class="line">b := elfobject.ConvertUnit32ToBytes(<span class="keyword">uint32</span>(offset))</span><br><span class="line">jmp = <span class="built_in">append</span>(jmp, b...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该函数只是封装了syscall.PtraceAttach(pid)</span></span><br><span class="line"><span class="keyword">if</span> e := p.PtraceAttach(); e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">status := <span class="built_in">new</span>(syscall.WaitStatus)</span><br><span class="line"><span class="keyword">if</span> _, err := syscall.Wait4(pid, status, <span class="number">0</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> status.Exited() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取写入地址</span></span><br><span class="line">offset = p.FindStartAddr() + addr1</span><br><span class="line">    <span class="comment">// 将跳转指令写入</span></span><br><span class="line">count, err := syscall.PtracePokeData(pid, <span class="keyword">uintptr</span>(offset), jmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/giphy.gif" data-lazy-src="/img/patch.gif" alt="patch"></p>]]></content>
    
    
    <summary type="html">对于一个正在运行中的进程，如何动态改变其函数跳转？</summary>
    
    
    
    <category term="热补丁" scheme="https://www.midoriya.com/categories/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
    
    <category term="ELF" scheme="https://www.midoriya.com/tags/ELF/"/>
    
    <category term="Go" scheme="https://www.midoriya.com/tags/Go/"/>
    
    <category term="Ptrace" scheme="https://www.midoriya.com/tags/Ptrace/"/>
    
  </entry>
  
  <entry>
    <title>热补丁之旅（四）实现一个ELF解析器</title>
    <link href="https://www.midoriya.com/hotpatch-4/"/>
    <id>https://www.midoriya.com/hotpatch-4/</id>
    <published>2021-02-11T14:29:25.000Z</published>
    <updated>2021-02-15T06:05:50.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><p>其实只需要将头文件<code>elf.h</code>中定义的结构体直接移植到Go中，再增加一些修改即可，为了盛事，我会省去很多参数。</p><p><code>elf.go</code></p><p>定义一些常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// class type</span></span><br><span class="line">ELFCLASS64 = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// little endian</span></span><br><span class="line"><span class="comment">// 字节序 小端序</span></span><br><span class="line">ELFDATA2LSB = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// big endian</span></span><br><span class="line"><span class="comment">// 字节序 大端序</span></span><br><span class="line">ELFDATA2MSB = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// object file type</span></span><br><span class="line"><span class="comment">// ELF文件类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ET_NONE = <span class="literal">iota</span></span><br><span class="line">ET_REL</span><br><span class="line">ET_EXEC</span><br><span class="line">ET_DYN</span><br><span class="line">ET_CORE</span><br><span class="line">ET_NUM</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义段的类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">PT_NULL = <span class="literal">iota</span></span><br><span class="line">PT_LOAD</span><br><span class="line">PT_DYNAMIC</span><br><span class="line">PT_INTERP</span><br><span class="line">PT_NOTE</span><br><span class="line">PT_SHLIB</span><br><span class="line">PT_PHDR</span><br><span class="line">PT_TLS</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Sym64Size = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义节的类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">SHT_NULL = <span class="literal">iota</span></span><br><span class="line">SHT_PROGBITS</span><br><span class="line">SHT_SYMTAB</span><br><span class="line">SHT_STRTAB</span><br><span class="line">SHT_RELA</span><br><span class="line">SHT_HASH</span><br><span class="line">SHT_DYNAMIC</span><br><span class="line">SHT_NOTE</span><br><span class="line">SHT_NOBITS</span><br><span class="line">SHT_REL</span><br><span class="line">SHT_SHLIB</span><br><span class="line">SHT_DYNSYM</span><br><span class="line">SHT_INIT_ARRAY</span><br><span class="line">SHT_FINI_ARRAY</span><br><span class="line">SHT_PREINIT_ARRAY</span><br><span class="line">SHT_GROUP</span><br><span class="line">SHT_SYMTAB_SHNDX</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接着，定义相关的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ElfFile</span></span><br><span class="line"><span class="keyword">type</span> ElfFile <span class="keyword">struct</span> &#123;</span><br><span class="line">*io.SectionReader</span><br><span class="line">ByteOrder binary.ByteOrder</span><br><span class="line"></span><br><span class="line">ehdr *ElfEhdr64</span><br><span class="line">phdr []*ElfPhdr64</span><br><span class="line">shdr []*ElfShdr64</span><br><span class="line"></span><br><span class="line">FileSize <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElfEhdr64 <span class="keyword">struct</span> &#123;</span><br><span class="line">Ident     [<span class="number">16</span>]<span class="keyword">byte</span></span><br><span class="line">Type      <span class="keyword">uint16</span></span><br><span class="line">Machine   <span class="keyword">uint16</span></span><br><span class="line">Version   <span class="keyword">uint32</span></span><br><span class="line">Entry     <span class="keyword">uint64</span></span><br><span class="line">Phoff     <span class="keyword">uint64</span></span><br><span class="line">Shoff     <span class="keyword">uint64</span></span><br><span class="line">Flags     <span class="keyword">uint32</span></span><br><span class="line">Ehsize    <span class="keyword">uint16</span></span><br><span class="line">PhentSize <span class="keyword">uint16</span></span><br><span class="line">Phnum     <span class="keyword">uint16</span></span><br><span class="line">ShentSize <span class="keyword">uint16</span></span><br><span class="line">Shnum     <span class="keyword">uint16</span></span><br><span class="line">Shstrndx  <span class="keyword">uint16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElfPhdr64 <span class="keyword">struct</span> &#123;</span><br><span class="line">*ElfPhdr64Header</span><br><span class="line"></span><br><span class="line">sr *io.SectionReader</span><br><span class="line">io.ReaderAt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElfPhdr64Header <span class="keyword">struct</span> &#123;</span><br><span class="line">Type   <span class="keyword">uint32</span></span><br><span class="line">Flags  <span class="keyword">uint32</span></span><br><span class="line">Offset <span class="keyword">uint64</span></span><br><span class="line">Vaddr  <span class="keyword">uint64</span></span><br><span class="line">Paddr  <span class="keyword">uint64</span></span><br><span class="line">FileSz <span class="keyword">uint64</span></span><br><span class="line">MemSz  <span class="keyword">uint64</span></span><br><span class="line">Align  <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElfShdr64 <span class="keyword">struct</span> &#123;</span><br><span class="line">*ElfShdr64Header</span><br><span class="line"></span><br><span class="line">io.ReaderAt</span><br><span class="line">sr *io.SectionReader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElfShdr64Header <span class="keyword">struct</span> &#123;</span><br><span class="line">Name      <span class="keyword">uint32</span></span><br><span class="line">Type      <span class="keyword">uint32</span></span><br><span class="line">Flags     <span class="keyword">uint64</span></span><br><span class="line">Addr      <span class="keyword">uint64</span></span><br><span class="line">Offset    <span class="keyword">uint64</span></span><br><span class="line">Size      <span class="keyword">uint64</span></span><br><span class="line">Link      <span class="keyword">uint32</span></span><br><span class="line">Info      <span class="keyword">uint32</span></span><br><span class="line">AddrAlign <span class="keyword">uint64</span></span><br><span class="line">EntSize   <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Symbol <span class="keyword">struct</span> &#123;</span><br><span class="line">ElfSym64</span><br><span class="line"></span><br><span class="line">NameStr <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElfSym64 <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="keyword">uint32</span></span><br><span class="line">Info  <span class="keyword">uint8</span></span><br><span class="line">Other <span class="keyword">uint8</span></span><br><span class="line">Shndx <span class="keyword">uint16</span></span><br><span class="line">Value <span class="keyword">uint64</span></span><br><span class="line">Size  <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="读取ELF文件"><a href="#读取ELF文件" class="headerlink" title="读取ELF文件"></a>读取ELF文件</h2><p>将上一节末提到的小段代码封装一下，参照官方<code>debug/elf</code>的逻辑，来完善一下<code>Open</code>函数，该函数接收一个文件路径参数，返回我们定义的<code>ElfFile</code>结构体。</p><p>具体思路：</p><ol><li>读取前16个字节，即<code>ident数组</code>，校验文件并且获取一些必要的参数，例如<code>字节序</code>， <code>Class大小</code>。</li><li>读取文件开头<code>ElfEhdr64</code>结构体大小的字节数组， 即完成了对<code>Ehdr</code>的解析。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*ElfFile, error)</span></span> &#123;</span><br><span class="line">file, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sr := io.NewSectionReader(file, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;<span class="number">62</span>)</span><br><span class="line"><span class="comment">// 读取elf文件的ident</span></span><br><span class="line"><span class="keyword">var</span> ident [<span class="number">16</span>]<span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">if</span> _, err := file.ReadAt(ident[<span class="number">0</span>:], <span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是elf文件</span></span><br><span class="line"><span class="comment">// 校验前四位魔数</span></span><br><span class="line"><span class="keyword">if</span> ident[<span class="number">0</span>] != <span class="string">&#x27;\x7f&#x27;</span> || ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span> || ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span> || ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, NewParseErr(<span class="number">0</span>, <span class="string">&quot;not elf file&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ident[<span class="number">4</span>] != ELFCLASS64 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, NewParseErr(<span class="number">4</span>, <span class="string">&quot;current only support ELF 64 class&quot;</span>, ident[<span class="number">4</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">elfFile := <span class="built_in">new</span>(ElfFile)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字节序</span></span><br><span class="line"><span class="comment">// 一般是小端序</span></span><br><span class="line"><span class="keyword">switch</span> ident[<span class="number">5</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> ELFDATA2LSB:</span><br><span class="line">elfFile.ByteOrder = binary.LittleEndian</span><br><span class="line"><span class="keyword">case</span> ELFDATA2MSB:</span><br><span class="line">elfFile.ByteOrder = binary.BigEndian</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, NewParseErr(<span class="number">5</span>, <span class="string">&quot;unknown ELF Endian&quot;</span>, ident[<span class="number">5</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ehdr := <span class="built_in">new</span>(ElfEhdr64)</span><br><span class="line">ehdr.Ident = ident</span><br><span class="line">sr.Seek(<span class="number">0</span>, seekStart)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := binary.Read(sr, elfFile.ByteOrder, ehdr); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">elfFile.ehdr = ehdr</span><br><span class="line">elfFile.SectionReader = sr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取程序头表</span></span><br><span class="line">err = elfFile.readProgs(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取节头表</span></span><br><span class="line">err = elfFile.readSections(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存文件大小</span></span><br><span class="line">fileInfo, err := file.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">elfFile.FileSize = <span class="keyword">int64</span>(fileInfo.Size())</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> elfFile, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取程序头"><a href="#读取程序头" class="headerlink" title="读取程序头"></a>读取程序头</h2><p>根据上一步中得到的<code>ehdr</code>能够很轻松的完成对程序头的解析，<code>ehdr.Phnum</code>代表程序头的数量，<code>ehdr.Phoff</code>代表程序头的偏移地址，<code>ehdr.PhentSize</code>则表示每个程序头的大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readProgs 读取程序头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(elf *ElfFile)</span> <span class="title">readProgs</span><span class="params">(r io.ReaderAt)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">elf.phdr = <span class="built_in">make</span>([]*ElfPhdr64, <span class="number">0</span>, elf.ehdr.Phnum)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(elf.ehdr.Phnum); i++ &#123;</span><br><span class="line">off := <span class="keyword">int64</span>(elf.ehdr.Phoff) + <span class="keyword">int64</span>(i)*<span class="keyword">int64</span>(elf.ehdr.PhentSize)</span><br><span class="line">elf.Seek(off, seekStart)</span><br><span class="line"></span><br><span class="line">header := <span class="built_in">new</span>(ElfPhdr64Header)</span><br><span class="line"><span class="keyword">if</span> err := binary.Read(elf.SectionReader, elf.ByteOrder, header); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">phdr := <span class="built_in">new</span>(ElfPhdr64)</span><br><span class="line">phdr.ElfPhdr64Header = header</span><br><span class="line">phdr.sr = io.NewSectionReader(r, <span class="keyword">int64</span>(phdr.Offset), <span class="keyword">int64</span>(phdr.FileSz))</span><br><span class="line">elf.phdr = <span class="built_in">append</span>(elf.phdr, phdr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取节头"><a href="#读取节头" class="headerlink" title="读取节头"></a>读取节头</h2><p>思路与获取程序头时完全相同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readSections 读取节表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(elf *ElfFile)</span> <span class="title">readSections</span><span class="params">(r io.ReaderAt)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">elf.shdr = <span class="built_in">make</span>([]*ElfShdr64, <span class="number">0</span>, elf.ehdr.Shnum)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(elf.ehdr.Shnum); i++ &#123;</span><br><span class="line">off := <span class="keyword">int64</span>(elf.ehdr.Shoff) + <span class="keyword">int64</span>(i)*<span class="keyword">int64</span>(elf.ehdr.ShentSize)</span><br><span class="line">elf.Seek(off, seekStart)</span><br><span class="line"></span><br><span class="line">shdr := <span class="built_in">new</span>(ElfShdr64)</span><br><span class="line">header := <span class="built_in">new</span>(ElfShdr64Header)</span><br><span class="line"><span class="keyword">if</span> err := binary.Read(elf.SectionReader, elf.ByteOrder, header); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shdr.ElfShdr64Header = header</span><br><span class="line">shdr.sr = io.NewSectionReader(r, <span class="keyword">int64</span>(shdr.Offset), <span class="keyword">int64</span>(shdr.Size))</span><br><span class="line">shdr.ReaderAt = shdr.sr</span><br><span class="line">elf.shdr = <span class="built_in">append</span>(elf.shdr, shdr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取符号表"><a href="#获取符号表" class="headerlink" title="获取符号表"></a>获取符号表</h2><p>大多数情况下，我们可能需要获取一个特定节的数据，例如符号信息，像<code>nm</code>命令那样打印出每个函数的虚拟地址等等，实际上这个也很好实现，符号表的节类型是<code>SHT_SYMTAB</code>，只要根据这个判断即可。</p><p>可以封装一个根据节头类型获取对应符号信息的函数，这里有几点需要注意：</p><ol><li>节头中存有符号信息的只有<code>.dynsym节</code>和<code>symtab节</code></li><li>符号名称也就是函数的名称其实并不存在该节中，符号对应的名称存在另外一个节中，由<code>ElfShdr64Header</code>结构体中的<code>Link</code>字段标识存储的节序号。</li><li>符号结构体中的<code>Name</code>字段并不代表符号名称，而是指存储符号名称的另一个节里的字节数组的开始序号，想要获取到符号名称，需要根据这个<code>Name</code>的序号值去读取<code>Link</code>所指向的节里的数据，以<code>0</code>代表一个符号名称的结束，具体逻辑请参考<code>convertToString函数</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(elf *ElfFile)</span> <span class="title">getType</span><span class="params">(_type <span class="keyword">int</span>)</span> <span class="params">([]Symbol, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _type != SHT_DYNSYM &amp;&amp; _type != SHT_SYMTAB &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;getType function don&#x27;t support %d type&quot;</span>, _type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> symbols []Symbol</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> elf.shdr &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int</span>(v.Type) == _type &#123;</span><br><span class="line">data, err := GetData(v.sr, <span class="keyword">int</span>(v.Size))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">symtab := bytes.NewReader(data)</span><br><span class="line"><span class="keyword">if</span> symtab.Len()%Sym64Size != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;length of symbol section is not a multiple of Sym64Size&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strData, err := elf.stringTable(<span class="keyword">int</span>(v.Link))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤掉第一个符号信息</span></span><br><span class="line"><span class="comment">// 该符号信息必定为空</span></span><br><span class="line"><span class="keyword">var</span> skip [Sym64Size]<span class="keyword">byte</span></span><br><span class="line">symtab.Read(skip[:])</span><br><span class="line"></span><br><span class="line">symbols = <span class="built_in">make</span>([]Symbol, symtab.Len()/Sym64Size)</span><br><span class="line"></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">sym := <span class="built_in">new</span>(ElfSym64)</span><br><span class="line"><span class="keyword">for</span> symtab.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">binary.Read(symtab, elf.ByteOrder, sym)</span><br><span class="line"><span class="comment">// 这里的Name并不是符号的名称</span></span><br><span class="line">str, _ := convertToString(strData, <span class="keyword">int</span>(sym.Name))</span><br><span class="line">symbols[i].ElfSym64 = *sym</span><br><span class="line">symbols[i].NameStr = str</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> symbols, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;No section is type %v.&quot;</span>, _type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(elf *ElfFile)</span> <span class="title">stringTable</span><span class="params">(link <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> link &lt;= <span class="number">0</span> || link &gt;= <span class="built_in">len</span>(elf.shdr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;section has invalid string table link&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GetData(elf.shdr[link].sr, <span class="keyword">int</span>(elf.shdr[link].Size))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertToString</span><span class="params">(section []<span class="keyword">byte</span>, start <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> start &lt; <span class="number">0</span> || start &gt;= <span class="built_in">len</span>(section) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> end := start; end &lt; <span class="built_in">len</span>(section); end++ &#123;</span><br><span class="line"><span class="keyword">if</span> section[end] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(section[start:end]), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>基于上面编写的代码，可以轻易的扩展：</p><ol><li>获取某个函数的机器码</li><li>类似<code>nm</code>命令一样打印所有函数</li><li>……</li></ol>]]></content>
    
    
    <summary type="html">掌握了ELF文件的结构之后，从头开始写一个解析器就不再是什么难事，不信你点进来看看～</summary>
    
    
    
    <category term="热补丁" scheme="https://www.midoriya.com/categories/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
    
    <category term="ELF" scheme="https://www.midoriya.com/tags/ELF/"/>
    
    <category term="Go" scheme="https://www.midoriya.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>热补丁之旅（三）从byte里看ELF</title>
    <link href="https://www.midoriya.com/hotpatch-3/"/>
    <id>https://www.midoriya.com/hotpatch-3/</id>
    <published>2021-01-30T14:29:25.000Z</published>
    <updated>2021-02-15T07:11:16.156Z</updated>
    
    <content type="html"><![CDATA[<p>首先，先重温一个概念。</p><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p><code>字节序</code>其实就是多字节数据类型例如（uint64, int）等在内存中的存储顺序，一个字节是8个bit，而像uint64类型的数据则需要占据8个字节。</p><p>举个不太恰当的例子，你可以理解成现在有一张白纸，你想要往纸上写8个字，但是你不知道究竟是从左往右写好还是从右往左写好，而这个时候你的老师告诉你，交给他的纸条统统从左往右写，交给别的老师的纸条从右往左写。</p><p>这就是<code>字节序</code>,可以分为：</p><ul><li>大端序，低地址端存放高位字节；</li><li>小端序， 低地址端存放低位字节；</li></ul><p>引用网上找的一张图:</p><p><img src= "/img/giphy.gif" data-lazy-src="/images/byte.png" alt="byte"></p><p>在计算机内部，小端序被广泛应用于现代性CPU内部存储数据，而在其他场景例如网络传输和文件存储则使用大端序。</p><h2 id="从字节层面看ELF文件"><a href="#从字节层面看ELF文件" class="headerlink" title="从字节层面看ELF文件"></a>从字节层面看ELF文件</h2><p>PS: 从这一节开始，我将主要使用Go语言。</p><p>首先，读取二进制文件<code>main</code>的前32个字节，然后将它打印出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, _ := os.Open(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>)</span><br><span class="line">err := binary.Read(file, binary.LittleEndian, b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[127 69 76 70 2 1 1 0 0 0 0 0 0 0 0 0 3 0 62 0 1 0 0 0 176 5 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure><p>ELF文件的前16个字节是<code>ident</code>，开头的魔数正好也能对应上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span> = <span class="number">0x7f</span></span><br><span class="line"><span class="number">69</span> = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="number">76</span> = <span class="string">&#x27;L&#x27;</span></span><br><span class="line"><span class="number">70</span> = <span class="string">&#x27;F&#x27;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>还是以ELF文件的入口<code>e_entry</code>举例吧，这里再贴一下Elf_Ehdr的结构示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>e_ident[EI_NIDENT];<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Halfe_type;<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Halfe_machine;<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Worde_version;<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addre_entry;<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Offe_phoff;<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Offe_shoff;<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Worde_flags;<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Halfe_ehsize;<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Halfe_phentsize;<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Halfe_phnum;<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shentsize;<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Halfe_shnum;<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shstrndx;<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><p>现在我们要找的属性是<code>e_entry</code>，位于<code>e_ident</code>、<code>e_type</code>、<code>e_machine</code>、<code>e_version</code>之后。</p><p>查看<code>elf.h</code>头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type for a 16-bit quantity.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Half;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf64_Half;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Types for signed and unsigned 32-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word;</span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">int32_t</span>  Elf32_Sword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">int32_t</span>  Elf64_Sword;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type of addresses.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Addr;</span><br></pre></td></tr></table></figure><p><code>e_ident</code>是16字节的数组</p><p><code>e_type</code>是<code>Elf64_Half</code>类型，也就是<code>uint16_t</code>，占据两个字节</p><p><code>e_machine</code>同样，占据两个字节</p><p><code>e_version</code>是<code>Elf64_Word</code>类型，也就是<code>uint32_t</code>，占据4个字节</p><p>简单的计算一下，16+2+2+4=24</p><p>所以<code>e_entry</code>属性占据的字节从<code>main</code>文件的第25个字节处开始，那么一共占了几个字节呢？</p><p><code>e_entry</code>是<code>Elf64_Addr</code>的类型（在64位机器上），一共占据了8个字节， 因此<code>e_entry</code>的值就是<code>bytes[24:32]</code>。</p><p>按照上面打印出来的前32位字节数组计算，<code>e_entry</code> = [176 5 0 0 0 0 0 0]</p><p>176的十六进制数 = <code>0xb0</code></p><p>按照小端序的字节序排列顺序，<code>e_entry</code> = <code>0x5b0</code></p><p>接下来验证一下我们手动计算的结果。</p><h2 id="elfy-io"><a href="#elfy-io" class="headerlink" title="elfy.io"></a>elfy.io</h2><p>推荐一个好用的站点，能够直观呈象一个Elf文件。</p><p>站点地址 <a href="https://elfy.io/">https://elfy.io/</a></p><p>这里我上传了我自己编译的示例Elf文件<code>main</code>, 可以看到<code>e_entry</code>的计算结果无误。</p><p><img src= "/img/giphy.gif" data-lazy-src="/images/elfy.png" alt="elfy"></p><h2 id="一个ELF解析器的初步实现"><a href="#一个ELF解析器的初步实现" class="headerlink" title="一个ELF解析器的初步实现"></a>一个ELF解析器的初步实现</h2><p>可以将<code>elf.h</code>头文件中定义的结构体直接移植到Go中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ElfEhdr64 <span class="keyword">struct</span> &#123;</span><br><span class="line">Ident     [<span class="number">16</span>]<span class="keyword">byte</span></span><br><span class="line">Type      <span class="keyword">uint16</span></span><br><span class="line">Machine   <span class="keyword">uint16</span></span><br><span class="line">Version   <span class="keyword">uint32</span></span><br><span class="line">Entry     <span class="keyword">uint64</span></span><br><span class="line">Phoff     <span class="keyword">uint64</span></span><br><span class="line">Shoff     <span class="keyword">uint64</span></span><br><span class="line">Flags     <span class="keyword">uint32</span></span><br><span class="line">Ehsize    <span class="keyword">uint16</span></span><br><span class="line">PhentSize <span class="keyword">uint16</span></span><br><span class="line">Phnum     <span class="keyword">uint16</span></span><br><span class="line">ShentSize <span class="keyword">uint16</span></span><br><span class="line">Shnum     <span class="keyword">uint16</span></span><br><span class="line">Shstrndx  <span class="keyword">uint16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，读取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.Open(<span class="string">&quot;main&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sr := io.NewSectionReader(file, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;<span class="number">62</span>)</span><br><span class="line"></span><br><span class="line">ehdr := <span class="built_in">new</span>(ElfEhdr64)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := binary.Read(sr, binary.LittleEndian, ehdr); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, ehdr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，Elf文件的头部其实就解析完了，只需要在添加一些对值合法性的校验。</p><p>例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sr := io.NewSectionReader(file, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;<span class="number">62</span>)</span><br><span class="line"><span class="comment">// 读取elf文件的ident</span></span><br><span class="line"><span class="keyword">var</span> ident [<span class="number">16</span>]<span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">if</span> _, err := file.ReadAt(ident[<span class="number">0</span>:], <span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是elf文件</span></span><br><span class="line"><span class="comment">// 校验前四位魔数</span></span><br><span class="line"><span class="keyword">if</span> ident[<span class="number">0</span>] != <span class="string">&#x27;\x7f&#x27;</span> || ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span> || ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span> || ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, NewParseErr(<span class="number">0</span>, <span class="string">&quot;not elf file&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只支持64位的ELF文件</span></span><br><span class="line"><span class="keyword">if</span> ident[<span class="number">4</span>] != ELFCLASS64 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, NewParseErr(<span class="number">4</span>, <span class="string">&quot;current only support ELF 64 class&quot;</span>, ident[<span class="number">4</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">elfFile := <span class="built_in">new</span>(ElfFile)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ident[5]来判断当前ELF文件的字节序</span></span><br><span class="line"><span class="keyword">switch</span> ident[<span class="number">5</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> ELFDATA2LSB:</span><br><span class="line">elfFile.ByteOrder = binary.LittleEndian</span><br><span class="line"><span class="keyword">case</span> ELFDATA2MSB:</span><br><span class="line">elfFile.ByteOrder = binary.BigEndian</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, NewParseErr(<span class="number">5</span>, <span class="string">&quot;unknown ELF class&quot;</span>, ident[<span class="number">5</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从下一节开始，我将动手实现一个ELF文件的解析器。</p>]]></content>
    
    
    <summary type="html">在上一节中，利用&lt;elf.h&gt;这个头文件能够很轻松的将一个二进制文件映射成我们方便修改的结构，但其实这背后的原理也很简单</summary>
    
    
    
    <category term="热补丁" scheme="https://www.midoriya.com/categories/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
    
    <category term="C" scheme="https://www.midoriya.com/tags/C/"/>
    
    <category term="ELF" scheme="https://www.midoriya.com/tags/ELF/"/>
    
    <category term="Byte" scheme="https://www.midoriya.com/tags/Byte/"/>
    
  </entry>
  
  <entry>
    <title>热补丁之旅（二）ELF研究</title>
    <link href="https://www.midoriya.com/hotpatch-2/"/>
    <id>https://www.midoriya.com/hotpatch-2/</id>
    <published>2021-01-24T03:29:25.000Z</published>
    <updated>2021-02-15T07:15:31.294Z</updated>
    
    <content type="html"><![CDATA[<p>一个ELF文件由4部分组成</p><ol><li>ELF头 （ELF header）</li><li>程序头表 （Program header table）</li><li>节 （Section）</li><li>节头表 （Section header table）</li></ol><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>一个ELF文件可以分为以下几种类型 （由e_type的值决定）</p><ol><li><p>ET_NOTE </p><p>未知类型，表明文件类型不确定，或者还未定义</p></li><li><p>ET_REL </p><p>重定位文件，意味着这个文件里标记了一段可重定位的代码，也就是编译后的.o文件</p></li><li><p>ET_EXEC</p><p>可执行文件，就是通常所说的二进制文件。</p></li><li><p>ET_DYN</p><p>共享目标文件，一个动态的可链接的目标文件，也称为共享库，也就是so文件</p></li><li><p>ET_CORE</p><p>核心文件，在程序崩溃或者进程传递了一个SIGSEGV信号时，会在核心文件中记录整个进程的镜像信息</p></li></ol><h2 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h2><p>程序头是对二进制文件中段的描述，是程序装载所必需的一部分。段是在内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。</p><p>64位可执行文件程序头结构如下：（每个字段的详细值都可以从该节末的链接中查看）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>e_ident[EI_NIDENT];<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Halfe_type;<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Halfe_machine;<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Worde_version;<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addre_entry;<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Offe_phoff;<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Offe_shoff;<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Worde_flags;<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Halfe_ehsize;<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Halfe_phentsize;<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Halfe_phnum;<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shentsize;<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Halfe_shnum;<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shstrndx;<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><p>第一个字段<code>e_ident</code>是一个16字节的数组，用于标识文件。<code>e_ident</code>的前4个字节（即文件本身的前4个字节）是序列（0x7f, ‘E’, ‘L’, ‘F’)，用来将文件标记为ELF文件</p><p><code>e_type</code> 目标文件类型，主要值：</p><table><thead><tr><th>Name</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>ET_NOTE</td><td>0</td><td>未知类型</td></tr><tr><td>ET_REL</td><td>1</td><td>可重定位文件</td></tr><tr><td>ET_EXEC</td><td>2</td><td>可执行的二进制文件</td></tr><tr><td>ET_DYN</td><td>3</td><td>动态库so文件</td></tr><tr><td>ET_CORE</td><td>4</td><td>core文件</td></tr></tbody></table><p><code>e_machine</code>标明了该二进制文件的编译平台，例如<code>0x3e</code>代表AMD x86-64的架构</p><p>可以从文末的链接中查看每个字段的详细信息。</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>有几个比较重要的属性需要提前注意一下，后面写代码时会用到：</p><ol><li><p>e_phoff</p><p>segment的头部偏移</p></li><li><p>e_phentsize</p><p>segment的头部大小</p></li><li><p>e_phnum</p><p>segment的头部数量</p></li><li><p>e_shoff</p><p>section的头部偏移</p></li><li><p>e_shentsize</p><p>section的头部大小</p></li><li><p>e_shnum</p><p>section的头部数量</p></li></ol><h3 id="关于e-shstrndx"><a href="#关于e-shstrndx" class="headerlink" title="关于e_shstrndx"></a>关于<code>e_shstrndx</code></h3><p>ELF文件中的每个section都是有名字的，比如.data、.text，每个名字其实都是一个字符串，既然是字符串就需要一个字符串池来保存，而这个字符串池其实也是一个section。这个特殊的字符串池叫.shstrtab。</p><p>前面的示例图中其实也能够看到，所有section的头部都是连续存放在一起的，类似于一个数组，而这个e_shsrtndx变量就是.shstrtab这个节在这个数组中的下标。</p><h2 id="Program-headers"><a href="#Program-headers" class="headerlink" title="Program headers"></a>Program headers</h2><p>程序头是对二进制文件中段的描述，是程序装载必需的一部分。段（segment）是在内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中，可以通过引用原始ELF头中<code>e_phoff</code>的偏移量来得到程序头表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line">    Elf64_Word p_type;</span><br><span class="line">    Elf64_Word p_flags;</span><br><span class="line">    Elf64_Off p_offset; <span class="comment">/* Segment file offset */</span></span><br><span class="line">    Elf64_Addr p_vaddr; <span class="comment">/* Segment virtual address */</span></span><br><span class="line">    Elf64_Addr p_paddr; <span class="comment">/* Segment physical address */</span></span><br><span class="line">    Elf64_Xword p_filesz;   <span class="comment">/* Segment size in file */</span></span><br><span class="line">    Elf64_Xword p_memsz;    <span class="comment">/* Segment size in memory */</span></span><br><span class="line">    Elf64_Xword p_align;    <span class="comment">/* Segment alignment, file &amp; memory */</span></span><br><span class="line">  &#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><p>根据<code>p_type</code>的值，可以判断段的类型，从<code>elf.h</code>头文件中可以看到段的类型比较多</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>PT_NULL0/* Program header table entry unused */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_LOAD1/* Loadable program segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_DYNAMIC2/* Dynamic linking information */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_INTERP3/* Program interpreter */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_NOTE4/* Auxiliary information */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_SHLIB5/* Reserved */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_PHDR6/* Entry for header table itself */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_TLS7/* Thread-local storage segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>PT_NUM8/* Number of defined types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_LOOS0x60000000/* Start of OS-specific */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_GNU_EH_FRAME0x6474e550/* GCC .eh_frame_hdr segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_GNU_STACK0x6474e551/* Indicates stack executability */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_GNU_RELRO0x6474e552/* Read-only after relocation */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_LOSUNW0x6ffffffa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_SUNWBSS0x6ffffffa/* Sun Specific segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_SUNWSTACK0x6ffffffb/* Stack segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_HISUNW0x6fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_HIOS0x6fffffff/* End of OS-specific */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_LOPROC0x70000000/* Start of processor-specific */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_HIPROC0x7fffffff/* End of processor-specific */</span></span><br></pre></td></tr></table></figure><p>这里介绍一些比较重要的段。</p><h3 id="PT-LOAD"><a href="#PT-LOAD" class="headerlink" title="PT_LOAD"></a>PT_LOAD</h3><p>一个ELF文件至少有一个PT_LOAD类型的段，这类程序头描述的是可装载的段，也就是说，这种类型的段将被装载或者映射到内存中。</p><p>例如，一个需要动态链接的ELF可执行文件通常会包含以下两个可以装载的段（类型为PT_LOAD)</p><ol><li>存放程序代码的text段</li><li>存放全局变量和动态链接信息的data段</li></ol><p>text段也就是经常说的代码段，该段的权限一般设置为PT_X | PT_R ，0x05</p><p>data段也就是数据段，权限一般设置为PT_W  | PT_R （读和写）0x06</p><p>这里要注意的是，text段和data段都是<code>PT_LOAD</code>类型的段，判断段究竟是<code>text</code>段还是<code>data</code>段还需要取<code>p_offset</code>的值。</p><p><code>p_offset</code>等于0的<code>PT_LOAD</code>类型的段才是text段。</p><h3 id="PT-DYNAMIC"><a href="#PT-DYNAMIC" class="headerlink" title="PT_DYNAMIC"></a>PT_DYNAMIC</h3><p>动态段是动态链接可执行文件所特有的，包含了动态链接器所必需的一些信息。</p><ol><li>运行时需要链接的共享库列表</li><li>全局偏移表（GOT）的地址</li><li>重定位的相关信息</li></ol><h3 id="PT-NOTE"><a href="#PT-NOTE" class="headerlink" title="PT_NOTE"></a>PT_NOTE</h3><p>该类型的段可能保存了与系统相关的附加信息，在可执行文件实际运行时是不需要这个段的。</p><h3 id="PT-INTERP"><a href="#PT-INTERP" class="headerlink" title="PT_INTERP"></a>PT_INTERP</h3><p>该段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。</p><p>例如，<code>/lib/ld-linx.so.2</code>一般是指动态链接器的位置，也即程序解释器的位置。</p><h3 id="PT-PHDR"><a href="#PT-PHDR" class="headerlink" title="PT_PHDR"></a>PT_PHDR</h3><p>该段保存了程序头表的本身的位置和大小，保存了所有的Phdr对文件中段的描述信息。</p><h2 id="Section-header"><a href="#Section-header" class="headerlink" title="Section header"></a>Section header</h2><p>在每个段中，会有代码和数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。</p><h3 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h3><p>存放编译好的二进制可执行代码，如果存在Phdr，.text节就会存在于.text段中，由于.text节保存了程序代码，因此节的类型为<code>SHT_PROGBITS</code></p><h3 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h3><p>保存只读的数据，例如字符串常量、const的变量，只能在text段中找到.rodata节</p><h3 id="plt节"><a href="#plt节" class="headerlink" title=".plt节"></a>.plt节</h3><p>包含了动态链接器调用从共享库导入的函数所必需的相关代码</p><h3 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h3><p>.data节存在于data段中，保存了初始化的全局变量等数据</p><h3 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h3><p>保存了未进行初始化的全局变量，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。</p><h3 id="symtab"><a href="#symtab" class="headerlink" title=".symtab"></a>.symtab</h3><p>符号表，记录的则是函数和变量</p><h3 id="strtab"><a href="#strtab" class="headerlink" title=".strtab"></a>.strtab</h3><p>字符串表、字符串常量和变量名</p><h3 id="got-plt节"><a href="#got-plt节" class="headerlink" title=".got.plt节"></a>.got.plt节</h3><p>.got节保存了全局偏移表，.got节和.plt节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。</p><h3 id="dynsym节"><a href="#dynsym节" class="headerlink" title=".dynsym节"></a>.dynsym节</h3><p>保存了从共享库导入的动态符号信息，该节保存在text段中，节类型被标记为SHT_DYNSYM</p><p>一个<code>text</code>段的布局如下：</p><ul><li>[.text] 程序代码</li><li>[.rodata] 只读数据</li><li>[.hash] 符号散列表</li><li>[.dynsym] 共享目标文件符号数据</li><li>[.dynstr] 共享目录文件符号名称</li><li>[.plt] 过程链接表</li><li>[.rel.got] G.O.T重定位数据</li></ul><h2 id="ELF符号"><a href="#ELF符号" class="headerlink" title="ELF符号"></a>ELF符号</h2><p>符号是对某些类型的数据或者代码（如全局变量和函数）的符号引用。</p><p>例如，printf()函数会在动态符号表.dynsym中存有一个指向该函数的符号条目。</p><p>在大多数共享库和动态链接可执行文件中，存在两个符号表：<code>.dynsym</code>和<code>.symtab</code>。</p><p>.dynsym保存了引用来自外部文件符号的全局符号，如printf这样的库函数，.dynsym保存的符号是.symtab所保存符号的子集，.symtab中还保存了可执行文件的本地符号，如全局变量或者代码中定义的本地函数。</p><p>因此，.symtab保存了所有的符号，而.dynsym只保存动态/全局符号。</p><p>使用<code>readelf -S main</code>查看二进制文件的节头，这里我删去一些暂时无用的节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line"></span><br><span class="line">  [ 5] .dynsym           DYNSYM           00000000000002b8  000002b8</span><br><span class="line">       00000000000000f0  0000000000000018   A       6     1     8</span><br><span class="line"></span><br><span class="line">  [26] .symtab           SYMTAB           0000000000000000  00001040</span><br><span class="line">       0000000000000660  0000000000000018          27    43     8</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从打印出来的信息中可以看到一部分节的Flags被标记为了A（ALLOC）、WA（WRITE/ALLOC）或者AX（ALLOC/EXC）</p><p>.dynsym被标记了A（ALLOC），而.symtab则没有被标记</p><p><code>ALLOC</code>表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。.dynsym保存的符号只能在运行时被解析，因此是运行时动态链接器所需要的唯一符号。</p><p><code>.dynsym</code>符号表对于动态链接可执行文件的执行来说是必需的</p><p>一个64位ELF文件符号项的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      st_name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">    <span class="keyword">uint16_t</span>      st_shndx;</span><br><span class="line">    Elf64_Addr    st_value;</span><br><span class="line">    Uint64_t      st_size;</span><br><span class="line">&#125; Elf64_sym;</span><br></pre></td></tr></table></figure><ol><li><p>st_name</p><p>保存了指向符号表中字符串表（位于.dynstr或者.strtab）的偏移地址，偏移地址存放着符号的名称，如printf</p></li><li><p>st_value</p><p>存放符号的值（可能是地址或者位置偏移量）</p></li><li><p>st_size</p><p>存放了一个符号的大小</p></li><li><p>st_shndx</p><p>每个符号表条目的定义都与某些节对应，该变量保存了相关节头表的索引</p></li><li><p>st_info</p><p>符号类型</p></li></ol><h3 id="查看符号表条目"><a href="#查看符号表条目" class="headerlink" title="查看符号表条目"></a>查看符号表条目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s 二进制文件 # 注意是小写的s</span><br></pre></td></tr></table></figure><h2 id="修改ELF文件的入口"><a href="#修改ELF文件的入口" class="headerlink" title="修改ELF文件的入口"></a>修改ELF文件的入口</h2><p>好了，去掉那些长篇大论的废话，学习还是要从实践开始入手。</p><p>如果你对结构还有不清楚的地方，可以自行去谷歌学习一下，在这里我引用一张别的博客所画的结构图，文末有博客链接。</p><p><img src= "/img/giphy.gif" data-lazy-src="/img/elf-file-format.png" alt="avatar"></p><p>先从一个简单的功能开始，修改一个ELF文件的入口地址。</p><p>一段示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stage += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;initializer function (stage: %d) \n&quot;</span>, stage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finalizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stage += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finalizer function (stage: %d) \n&quot;</span>, stage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    stage += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main function (stage: %d) \n&quot;</span>, stage);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alternativeEntryPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stage += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is an alternative entry point to the program (stage: %d) \n&quot;</span>, stage);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>正常编译后的打印应该如下：</p><blockquote><p>initializer function (stage: 1)<br>main function (stage: 2)<br>finalizer function (stage: 3) </p></blockquote><p>现在来修改一下这个二进制文件，将它的入口函数修改为<code>alternativeEntryPoint</code></p><p>首先，找一下<code>alternativeEntryPoint</code>函数的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s test | grep alternativeEntryPoint</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">54: 000000000000074b    54 FUNC    GLOBAL DEFAULT   14 alternativeEntryPoint</span><br></pre></td></tr></table></figure><p>ok，可以看到<code>alternativeEntryPoint</code>函数的入口地址是<code>0x74b</code></p><p>然后，修改代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    Elf64_Ehdr *ehdr;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;test&quot;</span>, O_RDWR|O_CREAT, <span class="number">00777</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立内存映射</span></span><br><span class="line">    <span class="keyword">char</span> *mem = mmap(<span class="literal">NULL</span>, st.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mem == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ehdr = (Elf64_Ehdr *)mem;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;old entry: %lx&quot;</span>, ehdr-&gt;e_entry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这里将入口修改为0x74b</span></span><br><span class="line">    ehdr-&gt;e_entry = <span class="number">0x74b</span>;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译修改代码=&gt;执行，应该会打印出原本ELF文件的入口地址。</p><p>这时候，再用<code>readelf</code>命令查看一下二进制文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h test</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#39;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS&#x2F;ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x74b</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          6632 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         29</span><br><span class="line">  Section header string table index: 28</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>入口地址顺利修改成功，再次执行二进制文件，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is an alternative entry point to the program (stage: 1)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://chuquan.me/2018/05/21/elf-introduce/">http://chuquan.me/2018/05/21/elf-introduce/</a></p><p><a href="https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html">https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html</a></p><p><a href="https://paper.seebug.org/89/">https://paper.seebug.org/89/</a></p>]]></content>
    
    
    <summary type="html">要想反编译一个Linux二进制文件或者实现热补丁的原理，那么不可避免地，首先就需要理解二进制格式本身</summary>
    
    
    
    <category term="热补丁" scheme="https://www.midoriya.com/categories/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
    
    <category term="C" scheme="https://www.midoriya.com/tags/C/"/>
    
    <category term="ELF" scheme="https://www.midoriya.com/tags/ELF/"/>
    
  </entry>
  
  <entry>
    <title>热补丁之旅（一）开胃小菜</title>
    <link href="https://www.midoriya.com/hotpatch-1/"/>
    <id>https://www.midoriya.com/hotpatch-1/</id>
    <published>2021-01-23T13:29:25.000Z</published>
    <updated>2021-02-15T06:06:36.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>一段基础代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>热补丁就是在目标进程不重启的情况下，替换某些函数达到热升级的效果。</p><p>替换函数的过程是基于探针进行的，根据原函数的名称，找到函数入口的内存地址。</p><p>重写原函数的指令，使用<code>JMP</code>命令跳转到替换函数。</p><h2 id="热补丁过程"><a href="#热补丁过程" class="headerlink" title="热补丁过程"></a>热补丁过程</h2><ol><li><p>下载<a href="https://software.intel.com/content/www/us/en/develop/articles/pin-a-binary-instrumentation-tool-downloads.html">Inter Pin</a>，解压到某个目录下，后面将使用这个工具来实现替换函数的过程。</p></li><li><p>准备一个示例程序，先随便写个简单的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_msg</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter some thing\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    print_msg(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热补丁将要替换的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_msg</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!%s&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译后，执行下二进制文件<code>./main</code>，输出如下，打印的字符串为小写的<code>hello world!$&#123;name&#125;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please enter some thing</span><br><span class="line">wsq</span><br><span class="line">hello world!wsq</span><br></pre></td></tr></table></figure></li><li><p>准备热补丁函数<code>hotpatch.cpp</code>，将该文件放在<code>pin目录/source/tools/SimpleExamples</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pin.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="keyword">char</span> target_routine_name[] = <span class="string">&quot;print_msg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 补丁函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_msg_patched</span><span class="params">(<span class="keyword">void</span> *original_routine_ptr, <span class="keyword">int</span> *return_address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLOWORLD!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loaded_image_callback</span><span class="params">( IMG current_image, VOID *v )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// look for the routine in the loaded image</span></span><br><span class="line">    RTN current_routine = RTN_FindByName(current_image, target_routine_name);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// stop if the routine was not found in this image</span></span><br><span class="line">    <span class="keyword">if</span> (!RTN_Valid(current_routine))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip routines which are unsafe for replacement</span></span><br><span class="line">    <span class="keyword">if</span> (!RTN_IsSafeForProbedReplacement(current_routine))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Skipping unsafe routine &quot;</span> &lt;&lt; target_routine_name &lt;&lt; <span class="string">&quot; in image &quot;</span> &lt;&lt; IMG_Name(current_image) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replacement routine&#x27;s prototype: returns void, default calling standard, name, takes no arugments </span></span><br><span class="line">    PROTO replacement_prototype = PROTO_Allocate(PIN_PARG(<span class="keyword">void</span>), CALLINGSTD_DEFAULT, target_routine_name, PIN_PARG_END());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replaces the original routine with a jump to the new one </span></span><br><span class="line">    RTN_ReplaceSignatureProbed(current_routine, </span><br><span class="line">                               AFUNPTR(read_input_patched), </span><br><span class="line">                               IARG_PROTOTYPE, </span><br><span class="line">                               replacement_prototype,</span><br><span class="line">                               IARG_ORIG_FUNCPTR,</span><br><span class="line">                               IARG_FUNCARG_ENTRYPOINT_VALUE, <span class="number">0</span>,</span><br><span class="line">                               IARG_RETURN_IP,</span><br><span class="line">                               IARG_END);</span><br><span class="line"></span><br><span class="line">    PROTO_Free(replacement_prototype);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Successfully replaced &quot;</span> &lt;&lt; target_routine_name &lt;&lt; <span class="string">&quot; from image &quot;</span> &lt;&lt; IMG_Name(current_image) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIN_InitSymbols();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PIN_Init(argc, argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to initialize PIN.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// registers a callback for the &quot;load image&quot; action</span></span><br><span class="line">    IMG_AddInstrumentFunction(loaded_image_callback, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// runs the program in probe mode</span></span><br><span class="line">    PIN_StartProgramProbed();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>修改<code>pin目录/source/tools/SimpleExamples/makefile.rules</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改如下项</span><br><span class="line">TEST_TOOL_ROOTS :&#x3D; hotpatch</span><br></pre></td></tr></table></figure></li><li><p>该目录下执行<code>make</code>命令，应该会生成一个<code>obj-intel64</code>目录，里面存放着编译后的<code>hotpatch.so</code>文件</p></li><li><p>再次执行之前编译好的二进制文件，但先不输入name</p></li><li><p>执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ../../../pin -pid $&#123;测试进程的pid&#125; -t obj-intel64/hotpatch.so</span><br></pre></td></tr></table></figure></li><li><p>这时候回到执行二进制文件的窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please enter some thing</span><br><span class="line">&#x2F;&#x2F; 如果打印如下，则证明热补丁函数已经替换成功</span><br><span class="line">Successfully replaced print_msg from image &#x2F;home&#x2F;fguby&#x2F;cProjects&#x2F;ctest&#x2F;main</span><br></pre></td></tr></table></figure></li><li><p>随便输入一个name，输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsq  &#x2F;&#x2F; 这是我的输入</span><br><span class="line">HELLOWORLD!!  &#x2F;&#x2F; 程序输出</span><br></pre></td></tr></table></figure><p>你会发现<code>helloworld</code>字符串已经全部变成大写，而且不再打印你的输入。</p></li></ol>]]></content>
    
    
    <summary type="html">如何在进程不停止的情况下进行某些函数的替换呢？</summary>
    
    
    
    <category term="热补丁" scheme="https://www.midoriya.com/categories/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
    
    <category term="C" scheme="https://www.midoriya.com/tags/C/"/>
    
    <category term="Inter Pin" scheme="https://www.midoriya.com/tags/Inter-Pin/"/>
    
  </entry>
  
  <entry>
    <title>Go GC</title>
    <link href="https://www.midoriya.com/go-gc/"/>
    <id>https://www.midoriya.com/go-gc/</id>
    <published>2021-01-02T11:29:25.000Z</published>
    <updated>2021-02-15T06:22:50.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h2><p><strong>GC</strong>，全称<strong>GarbageCollection</strong>，即垃圾回收，是一种自动内存管理的机制。</p><p>当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请时候复用，或者将其归还给操作系统，这种针对内存级别资源的自动回收过程，即为垃圾回收。</p><p>通常，垃圾回收器的执行过程被划分为两个半独立的组件：</p><ul><li><strong>赋值器</strong>（Mutator）：这一名称本质上是在指代用户态的代码，因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系。</li><li><strong>回收器</strong>（Collector）：负责执行垃圾回收的代码。</li></ul><h2 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h2><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p><ol><li>全局变量：程序在编译器就能确定的那些存在于程序整个生命周期的变量</li><li>执行栈：每个goroutine都包含自己的执行栈，这些执行栈上包含栈上的变量以及指向分配的堆内存区块的指针</li><li>寄存器：寄存器的值可能表示一个指针</li></ol><h2 id="常见的GC实现方式"><a href="#常见的GC实现方式" class="headerlink" title="常见的GC实现方式"></a>常见的GC实现方式</h2><p>所有的GC算法其存在形式可以归结为追踪和引用计数这两种形式的混合运用</p><ul><li>追踪式GC</li><li>引用计数式GC</li></ul><p>GO的GC使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法，原因在于：</p><ol><li>对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。go运行时的分配算法基于tcmalloc，基本上没有碎片问题。</li><li>分代GC依赖分代假设，即GC将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象，但Go的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。</li></ol><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称：</p><ul><li>白色对象（可能死亡）：未被回收器访问到的对象，在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达</li><li>灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。</li><li>黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</li></ul><h2 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h2><p><strong>STW</strong>是指在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。</p><p>在这个过程中整个用户代码被停止或者放缓指向，STW越长，对用户代码造成的影响（例如延迟）就越大。</p><p>GC在进入STW时，需要等待让所有的用户态代码停止。</p><h2 id="如何观察Go-GC？"><a href="#如何观察Go-GC？" class="headerlink" title="如何观察Go GC？"></a>如何观察Go GC？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">()</span></span> &#123;</span><br><span class="line">_ = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">1</span>; n &lt; <span class="number">100000</span>; n++ &#123;</span><br><span class="line">allocate()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法1: <code>GODEBUG=gctrace=1</code></p><p>方法2: <code>go tool trace</code></p><p>主要功能是将统计而来的信息以一种可视化的方式展示给用户。</p><p>方法3: <code>debug.ReadGCStats</code></p><p>此方式可以通过代码的方式来直接实现对感兴趣指标的监控，例如一秒监控一次GC的状态。</p><h2 id="为什么会内存泄漏？"><a href="#为什么会内存泄漏？" class="headerlink" title="为什么会内存泄漏？"></a>为什么会内存泄漏？</h2><h3 id="形式1-预期能被快速释放的内存因被根对象引用而没有得到迅速释放。"><a href="#形式1-预期能被快速释放的内存因被根对象引用而没有得到迅速释放。" class="headerlink" title="形式1: 预期能被快速释放的内存因被根对象引用而没有得到迅速释放。"></a>形式1: 预期能被快速释放的内存因被根对象引用而没有得到迅速释放。</h3><p>当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> cache <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepalloc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">m := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span> &lt;&lt; <span class="number">10</span>)</span><br><span class="line">cache[i] = m</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="形式2-goroutine泄漏"><a href="#形式2-goroutine泄漏" class="headerlink" title="形式2: goroutine泄漏"></a>形式2: goroutine泄漏</h3><p>Goroutine作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的Go中是不会被释放的。因此，如果一个程序持续不断地产生新的goroutine、且不结束已经创建的goroutine并复用这部分内存，就会造成内存泄漏的现象。</p><h2 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h2><p>没有用户态代码并发修改三色抽象的情况下，回收可以正常结束，但是并发回收的根本问题在于，用户态代码在回收过程中会并发地更新对象图，从而造成赋值器和回收器可能对对象图的结构产生不同的认知。</p><ul><li>初始状态：假设某个黑色对象C指向某个灰色对象A，而A指向白色对象B；</li><li>C.ref3 = c.ref2.ref1:赋值器并发地将黑色对象C指向（ref3）了白色对象B；</li><li>A.ref1 = nil: 移除灰色对象A对白色对象B的引用（ref2）</li><li>最终状态：在继续扫描的过程中，白色对象B永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象），进而对象B被错误地回收</li></ul><p>并发标记清除中面临的一个根本问题就是如何保证标记与清除过程的正确性。</p><h2 id="什么是写屏障、混合写屏障，如何实现？"><a href="#什么是写屏障、混合写屏障，如何实现？" class="headerlink" title="什么是写屏障、混合写屏障，如何实现？"></a>什么是写屏障、混合写屏障，如何实现？</h2><p>写屏障是一个在并发垃圾回收器中才会出现的概念，垃圾回收器的正确性体现在：不应出现对象的丢失，也不应错误的回收还不需要回收的对象。</p><p>当以下两个条件同时满足时会破坏垃圾回收器的正确性：</p><ul><li>条件1:赋值器修改对象图，导致某一黑色对象引用白色对象</li><li>条件2:从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏</li></ul><p>只要能够避免其中任何一个条件，就不会出现对象丢失的情况，因为：</p><ul><li>如果条件1被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；</li><li>如果条件2被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。</li></ul><p>将三色不变性所定义的波面根据这两个条件进行削弱：</p><ul><li>当满足原有的三色不变性定义（或上面的两个条件都不满足时）的情况称为强三色不变性</li><li>当赋值器令黑色对象引用白色对象时的情况称为弱三色不变性</li></ul><p>当赋值器进一步破坏灰色对象到达白色对象的路径时，即打破弱三色不变性，也就破坏了回收器的正确性；</p><p>弱三色不变性的好处在于：只要存在未访问的能够到达白色对象的路径，就可以将黑色对象指向白色对象。</p><p>在允许灰色赋值器存在的算法，最坏的情况下，回收器只能将所有赋值器线程停止才能完成其根对象的完整扫描，也就是我们说的STW。</p><p>为了确保强弱三色不变性的并发指针更新操作，需要通过赋值器屏障技术来保证指针的读写操作一致，赋值器的写屏障用来保证赋值器在进行指针写操作时，不会破坏弱三色不变性。</p><blockquote><p>黑色赋值器：已经由回收器扫描过，不会再次对其进行扫描<br>灰色赋值器：尚未被回收器扫描，或尽管已经扫描过但扔需要重新扫描</p></blockquote><p>有两种非常经典的写屏障：Dijkstra插入屏障和Yuasa删除屏障。</p><p>灰色赋值器的Dijkstra插入屏障的基本思想是避免满足条件1，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DijkstraWritePointer</span><span class="params">(slot *unsafe.Pointer, ptr unsafe.Pointer)</span></span> &#123;</span><br><span class="line">shade(ptr)</span><br><span class="line">*slot = ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止黑色对象指向白色对象，应该假设<code>*slot</code>可能会变为黑色，为了确保<code>ptr</code>不会在被赋值到<code>*slot</code>前变为白色，<code>shade(ptr)</code>会先将指针ptr标记为灰色，进而避免了条件1.</p><p>但是，由于并不清楚赋值器以后会不会将这个引用删除，因此还需要重新扫描来重新确定关系图，这时需要STW。</p><p>插入屏障的好处在于可以立刻开始并发标记，但是因为产生了灰色的赋值器，缺陷是需要标记终止阶段STW时进行重新扫描。</p><p>黑色赋值器的Yuasa删除屏障的基本思想是避免满足条件2:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//黑色赋值器Yuasa屏障</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">YuasaWritePointer</span><span class="params">(slot *unsafe.Pointer, ptr unsafe.Pointer)</span></span> &#123;</span><br><span class="line">shade(*slot)</span><br><span class="line">*slot = ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止丢失从灰色对象到白色对象的路径，应该假设<code>*slot</code>可能会变为黑色，为了确保<code>ptr</code>不会在被赋值到<code>*slot</code>前变为白色，<code>shade(*slot)</code>会先将<code>*slot</code>标记为灰色，进而该写操作总是创造了一条灰色到灰色或者灰色到白色对象的路径。</p><p>Yuasa删除屏障的优势在于不需要标记结束阶段的重新扫描，缺陷是依然会产生丢失的对象，需要在标记开始前对整个对象图进行快照。</p><p>Go在1.8的时候为了简化GC的流程，同时减少标记终止阶段的重扫成本，将Dijkstra插入屏障和Yuasa删除屏障进行混合，形成混合写屏障。</p><p>该屏障提出的基本思想是：</p><blockquote><p>对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色。</p></blockquote><h2 id="GC的流程"><a href="#GC的流程" class="headerlink" title="GC的流程"></a>GC的流程</h2><p>当前版本的Go以STW为界限，可以将GC划分为五个阶段：</p><ul><li>GCMark<br>标记准备阶段，为并发标记做准备工作，启动写屏障<br>赋值器处于STW状态</li><li>GCMARK<br>扫描标记阶段，与赋值器并发执行，写屏障开启<br>赋值器处于并发状态</li><li>GCMarkTermination<br>标记终止阶段，保证一个周期内标记任务完成，停止写屏障<br>赋值器这时处于STW状态</li><li>GCoff<br>内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭<br>赋值器处于并发状态</li><li>GCoff<br>内存归还阶段，将过多的内存归还给操作系统，写屏障关闭<br>赋值器处于并发状态</li></ul><h2 id="触发GC的时机是什么？"><a href="#触发GC的时机是什么？" class="headerlink" title="触发GC的时机是什么？"></a>触发GC的时机是什么？</h2><p>Go语言中对GC的触发时机存在两种形式:</p><ol><li>主动触发，通过调用runtime.GC来触发GC，此调用阻塞式地等待当前GC运行完毕</li><li>被动触发，分为两种方式<ul><li>使用系统监控，当超过两分钟没有产生任何GC时，强制触发GC</li><li>使用步调算法，其核心思想是控制内存增长的比例</li></ul></li></ol><h2 id="如果内存分配速度超过标记清除的速度怎么办？"><a href="#如果内存分配速度超过标记清除的速度怎么办？" class="headerlink" title="如果内存分配速度超过标记清除的速度怎么办？"></a>如果内存分配速度超过标记清除的速度怎么办？</h2><p>目前的Go实现中，当GC触发后，会首先进入并发标记的阶段。并发标记会设置一个标志，并在mallocgc调用时进行检查。<br>当存在新的内存分配时，会暂停分配内存过快的那些goroutine，并将其转去执行一些辅助标记的工作，从而达到放缓继续分配，辅助GC的标记工作的目的。<br>编译器会分析用户代码，并在需要分配内存的位置，将申请内存的操作翻译为mallocgc调用。</p><h2 id="Go的GC如何调优"><a href="#Go的GC如何调优" class="headerlink" title="Go的GC如何调优"></a>Go的GC如何调优</h2><p>Go可供用户调整的参数只有GOGC环境变量，当我们谈论GC调优时，通常是指减少用户代码对GC产生的压力，这一方面包含了减少用户代码分配内存的数量，另外一方面包含了最小化Go的GC对CPU的使用率（即调整GOGC）</p><p>GC调优的核心思想：优化内存的申请速度，尽可能的少申请内存，复用已申请的内存。</p><p>GC的触发原则是由步调算法来控制的，关键在于估计下一次需要触发GC时，堆的大小。如果我们在遇到海量请求的时候，为了避免GC频繁触发，可以将GOGC的值设置得更大，让GC触发的时间变得更晚。</p><h2 id="相关APi"><a href="#相关APi" class="headerlink" title="相关APi"></a>相关APi</h2><ul><li>runtime.GC 手动触发GC</li><li>runtime.ReadMemstats 读取内存相关的统计信息，其中包含部分GC相关的统计信息</li><li>debug.FreeOSMemory 手动将内存归还给操作系统</li><li>debug.ReadGCStats 读取关于GC的相关统计信息</li><li>debug.SetGCPerent 设置GOGC调步变量</li></ul>]]></content>
    
    
    <summary type="html">GC，全称GarbageCollection，即垃圾回收，是一种自动内存管理的机制，go语言中采用的GC算法又叫三色标记法。</summary>
    
    
    
    <category term="Golang" scheme="https://www.midoriya.com/categories/Golang/"/>
    
    
    <category term="GC" scheme="https://www.midoriya.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>美化系列小记：Hexo博客</title>
    <link href="https://www.midoriya.com/beautify-blog/"/>
    <id>https://www.midoriya.com/beautify-blog/</id>
    <published>2020-12-27T13:29:25.000Z</published>
    <updated>2021-02-15T12:55:51.445Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是美化系列小记的第一篇，如何美化自己的博客。</p><h2 id="博客框架"><a href="#博客框架" class="headerlink" title="博客框架"></a>博客框架</h2><p>我用过Hexo和Hugo，就个人而言，可能Hexo目前更好用一些，毕竟主题丰富，尽管Hugo号称构建网站最快的框架，但是在主题和插件的支持上目前还比不上Hexo。</p><p>Hexo的基本使用参考官网即可，这里就不描述了。</p><h2 id="选取主题"><a href="#选取主题" class="headerlink" title="选取主题"></a>选取主题</h2><p>在Hexo官网的主题页面或者是github里，你能搜到一大把好看的主题，只要选择自己心仪的那一个即可，一般主题的作者也都会在README.md里添上详细的安装教程，当然基本都大同小异。</p><ol><li><p><code>git clone 主题库</code></p></li><li><p>将主题放入到theme里即可，然后修改<code>_config.yaml</code></p></li><li><p>添加主题特有的配置</p></li></ol><h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p>以我的博客举例，使用的是valine。</p><p><a href="https://valine.js.org/quickstart.html">参考这篇教程</a></p><p>使用起来还是很简单、方便 的，基本上注册完填写对应App ID 和App Key就行了，在主题里的配置基本也都差不多，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">xxxx</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">xxxx</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">ヽ(○´∀`)ﾉ♪</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mp</span> <span class="comment"># Gravatar style : mp, identicon, monsterid, wavatar, robohash, retro</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">en</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">NoRecordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="attr">powerMode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tagMeta:</span></span><br><span class="line">    <span class="attr">visitor:</span> <span class="string">孤荡的灵魂</span></span><br><span class="line">    <span class="attr">master:</span> <span class="string">主人</span></span><br><span class="line">    <span class="attr">friend:</span> <span class="string">基友们</span></span><br><span class="line">    <span class="attr">investor:</span> <span class="string">土豪</span></span><br><span class="line">  <span class="attr">tagColor:</span></span><br><span class="line">    <span class="attr">master:</span> <span class="string">&amp;quot;var(--color-orange)&amp;quot;</span></span><br><span class="line">    <span class="attr">friend:</span> <span class="string">&amp;quot;var(--color-aqua)&amp;quot;</span></span><br><span class="line">    <span class="attr">investor:</span> <span class="string">&amp;quot;var(--color-pink)&amp;quot;</span></span><br><span class="line">  <span class="attr">tagMember:</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="comment"># - hash of master@email.com</span></span><br><span class="line">      <span class="comment"># - hash of master2@email.com</span></span><br><span class="line">    <span class="attr">friend:</span></span><br><span class="line">      <span class="comment"># - hash of friend@email.com</span></span><br><span class="line">      <span class="comment"># - hash of friend2@email.com</span></span><br><span class="line">    <span class="attr">investor:</span></span><br><span class="line">      <span class="comment"># - hash of investor1@email.com</span></span><br></pre></td></tr></table></figure><h2 id="搜索功能-algolia"><a href="#搜索功能-algolia" class="headerlink" title="搜索功能-algolia"></a>搜索功能-algolia</h2><p>建站的时候摸索了一会儿algolia的使用办法，在这里记录下。如果你选择的博客主题也使用了algolia，那么可以参考下。</p><ol><li><p>首先也是注册账号，注册完以后在界面左部的菜单栏找到API Keys一栏，点击后你就能看到自己的Application ID等必要信息。</p></li><li><p>新建一个用来搜索的index，博客的数据到时候也会上传到这里。</p></li><li><p>在API Keys界面里新建一个API Key（点击第一个红框圈住的按钮），在添加的界面里<strong>Indices</strong>中选择步骤2里新建的index，然后在<strong>ACL</strong>一栏中选中<code>listIndexes</code>，<code>deleteObject</code>，<code>addObject</code></p></li></ol><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/example1227-1.png" alt="avatar" title="示例一"></p><ol start="4"><li><p>之后在示例的截图中红框圈住的部分就会生成一个API Keys。</p></li><li><p>安装algolia插件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure></li><li><p>步骤4中得到的API Keys就是单独的API密钥，执行如下命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HEXO_ALGOLIA_INDEXING_KEY=API密钥</span><br><span class="line">./node_modules/.bin/hexo algolia</span><br></pre></td></tr></table></figure></li><li><p>End</p></li></ol><h2 id="live2D看板娘"><a href="#live2D看板娘" class="headerlink" title="live2D看板娘"></a>live2D看板娘</h2><p>如果想配置live2D看板娘在你的博客上，也很简单，hexo有现成的插件，直接安装即可使用。</p><p><a href="https://github.com/EYHN/hexo-helper-live2d">插件的github地址</a></p><ol><li><p>安装模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure></li><li><p>参照Example，这里贴下我的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#enable: false</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">rem</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">1.7</span></span><br><span class="line">    <span class="attr">hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line">    <span class="comment"># use: live2d-widget-model-wanko # npm-module package name</span></span><br><span class="line">    <span class="comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 相对于博客根目录的路径</span></span><br><span class="line">    <span class="comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">360</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span> <span class="comment"># 是否在移动设备上显示</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">1.5</span> <span class="comment"># 移动设备上的缩放</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure></li></ol><p>模型可以自己去找，我使用的是雷姆和小埋的模型，如果你也想要的话，可以联系我。</p><h2 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a>打字机效果</h2><p>有些你喜欢的主题可能本身并没有带打字机的效果，这时候其实可以自己手动加一下。</p><p><a href="https://mattboldt.com/demos/typed-js/">typed-js</a></p><ol><li>安装typedjs或者直接引用CDN链接。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/typed.js@2.0.11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加配置，官方的文档对于各种属性都解释的很清楚，这里贴下我的配置。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  strings: msgs,</span><br><span class="line">  typeSpeed: <span class="number">250</span>,</span><br><span class="line">  loop: <span class="literal">false</span>,</span><br><span class="line">  loopCount: <span class="literal">Infinity</span>,</span><br><span class="line">  backSpeed: <span class="number">100</span>,</span><br><span class="line">  cursorChar: <span class="string">&#x27;❤&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">typed = <span class="keyword">new</span> Typed(<span class="string">&#x27;.artboard&#x27;</span>, options);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>在页面上用F12查看你想要显示打字机效果的部分，把class的值或者是id的值记下来即可，第4步会用到。</p></li><li><p>在主题的layout目录下找找，看看header或者是footer对应的文件是哪个，把上面这段代码直接无脑拷贝进去即可，例如这样。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/typed.js@2.0.11&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    strings: msgs,</span><br><span class="line">    typeSpeed: <span class="number">250</span>,</span><br><span class="line">    loop: <span class="literal">false</span>,</span><br><span class="line">    loopCount: <span class="literal">Infinity</span>,</span><br><span class="line">    backSpeed: <span class="number">100</span>,</span><br><span class="line">    cursorChar: <span class="string">&#x27;❤&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以是id选择器也可以是class选择器</span></span><br><span class="line">     typed = <span class="keyword">new</span> Typed(<span class="string">&#x27;.artboard&#x27;</span>, options);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇是美化系列小记的第一篇，如何美化自己的博客。&lt;/p&gt;
&lt;h2 id=&quot;博客框架&quot;&gt;&lt;a href=&quot;#博客框架&quot; class=&quot;headerlink&quot; title=&quot;博客框架&quot;&gt;&lt;/a&gt;博客框架&lt;/h2&gt;&lt;p&gt;我用过Hexo和Hugo，就个人而言，可能Hexo目前更好用</summary>
      
    
    
    
    <category term="美化教程" scheme="https://www.midoriya.com/categories/%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="美化" scheme="https://www.midoriya.com/tags/%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Go Scheduler</title>
    <link href="https://www.midoriya.com/Golang/"/>
    <id>https://www.midoriya.com/Golang/</id>
    <published>2020-12-26T17:29:25.000Z</published>
    <updated>2021-02-15T06:22:11.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OS-Scheduler"><a href="#OS-Scheduler" class="headerlink" title="OS Scheduler"></a>OS Scheduler</h2><p>从操作系统角度看，程序最终都会转换成一系列的机器指令，机器只要按顺序执行完所有的指令就算完成了任务。</p><p>完成“按顺序执行指令”任务的实体就是线程，也就是说，线程是CPU调度的实体，是真正在CPU上执行指令的实体。</p><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>OS Scheduler调度线程的依据就是它的状态，线程的三种状态：</p><ul><li>Waiting 等待状态，线程在等待某件事的发生，例如等待网络数据、硬盘；调用操作系统API；等待内存同步访问条件ready，如atomic，mutexes</li><li>Runnable 就绪状态，只要给CPU资源就能运行</li><li>Executing 运行状态</li></ul><h2 id="什么是goroutine"><a href="#什么是goroutine" class="headerlink" title="什么是goroutine"></a>什么是goroutine</h2><p>Goroutine可以看作是对线程加的一层抽象，它更轻量级，可以单独执行，不是OS线程，也不是绿色线程（由语言的运行时管理的线程）。</p><h2 id="goroutine和thread的区别"><a href="#goroutine和thread的区别" class="headerlink" title="goroutine和thread的区别"></a>goroutine和thread的区别</h2><p>可以从三个角度区别：内存消耗、创建与销毁、切换</p><ul><li>内存占用<br>创建一个goroutine的栈内存消耗为2KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。<br>创建一个thread则需要消耗1MB栈内存。</li><li>创建和销毁<br>Thread创建和销毁都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而goroutine因为是由Go runtime负责管理的，创建和销毁的销毁非常小，是用户级。</li><li>切换<br>线程切换的时候，需要保存各种寄存器，以便将来恢复，goroutine的切换只需要保存三个寄存器：PC, SP, BP。</li></ul><h2 id="M-N模型"><a href="#M-N模型" class="headerlink" title="M:N模型"></a>M:N模型</h2><p>Go runtime会负责Goroutine的生老病死，从创建到销毁，都一手包办。</p><p>Runtime会在程序启动的时候，创建M个线程（CPU执行调度的单位），之后创建的N个goroutine都会依附在这M个线程上执行。</p><p>在同一时刻，一个线程上只能跑一个goroutine，当goroutine发生阻塞时，runtime会把当前的goroutine调度走，让其他goroutine来执行。</p><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>Runtime维护所有的goroutines，并通过scheduler来进行调度。</p><p>有三个基础的结构体来实现goroutines的调度。</p><p>::G::：代表一个goroutine<br>::M::：表示内核线程，包含正在运行的goroutine等字段<br>::P::：代表g执行的上下文环境，它维护一个处于Runable状态的G队列，M需要获得P才能运行G。</p><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*QaG177Xaz7hHBaJSxSDjBA.png" alt="avatar"></p><p>每个Goroutine在OS线程上（M）运行。</p><p>Runtime在运行时会启动一些G：垃圾回收的G，执行调度的G，运行用户代码的G；并且会创建一个M用来开始G的运行，随着时间推移，更多的G会被创建出来，更多的M也会被创建出来。</p><p>GO Scheduler的核心思想就是:</p><ol><li>reuse threads;（复用线程）</li><li>限制同时运行的线程数为N，N等于CPU的核心数目；（N可以由GOMAXPROCS变量来决定）</li><li>线程私有的runqueues，并且可以从其他线程stealing goroutine来运行，线程阻塞后，可以将runqueues传递给其他线程。</li></ol><p>Go程序启动后，会给每个逻辑核心分配一个P，同时会给每个P分配一个M，内核线程依然由OS Scheduler来调度。</p><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><p>假设一段代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   var wg sync.WaitGroup</span><br><span class="line">   wg.Add(2)</span><br><span class="line"></span><br><span class="line">   go func() &#123;</span><br><span class="line">      println(&#96;hello&#96;)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   go func() &#123;</span><br><span class="line">      println(&#96;world&#96;)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go首先会根据逻辑CPU核心数创建不同的P，并且将这些P存储在一个空闲的P列表中。</p><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*R8hPBHK-8aultosys9D8tQ.png" alt="avatar"></p><p>接下来，当有新的Goroutine或者是准备运行的Goroutine将唤醒P以更好地分配工作。</p><p>这个P将创建一个关联的M（系统线程）：<br><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*CCguz8qrjngfk98HlTpcYA.png" alt="1*CCguz8qrjngfk98HlTpcYA"></p><p>当遇到以下情况时P又会重新回到上面的空闲列表中：</p><ul><li>没有Goroutine准备或是等待运行</li><li>从系统调用中返回</li><li>被垃圾收集器停止（也就是所谓的STW，stop the world）</li></ul><p>在程序的启动期间，Go已经创建了一些OS线程和相关的M。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>Go通过将它们包装在runtime中来优化系统调用（无论是否阻塞），这个包装器将自动从线程M上分离出P并且允许另一个线程来运行它。<br>以读取文件为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>（）</span>&#123; </span><br><span class="line">   buf：= <span class="built_in">make</span>（[] <span class="keyword">byte</span>，<span class="number">0</span>，<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line">   fd，_：= os.Open（“number.txt”）</span><br><span class="line">   fd.Read（buf）</span><br><span class="line">   fd.Close（）</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>（<span class="keyword">string</span>（buf)）<span class="comment">// 42 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是打开文件时的工作流程：</p><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*l56efREv5Exm21lzNeKt_w.png" alt="1*l56efREv5Exm21lzNeKt_w"></p><p>当主协程中执行os.Open()函数时，线程M0进入阻塞状态，p0回到空闲列表中并且处于可运行状态。</p><p>然后，当系统调用退出，Go就会应用以下规则，直到可以满足：</p><ul><li>试图获得完全一样的P，p0在空闲列表中，可以继续执行</li><li>尝试在空闲列表中获取一个p执行</li><li>把Goroutine放到全局可运行队列中，并且将M放回空闲列表中</li></ul><p>但是在非阻塞IO（例如http调用）的情况下，Go还可以处理资源尚未准备就绪的情况。在这种情况下，由于资源尚未准备就绪，Go将使用网络轮询器将Goroutine停放。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.Get(<span class="string">`https://httpstat.us/200`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦完成第一个系统调用并明确资源尚未准备就绪，goroutine将驻留，直到网络轮询器通知，在这种情况下，线程M将不会被阻塞。</p><p>Go调度程序查找后，线程M将会运行另外一个Goroutine。</p><p>如果准备了多个goroutine，则多余的goroutine将进入全局可运行队列，并在以后进行调度。</p><h2 id="GRQ和LRQ"><a href="#GRQ和LRQ" class="headerlink" title="GRQ和LRQ"></a>GRQ和LRQ</h2><p>全局可运行队列(GRQ)以及本地可运行队列(LRQ)</p><p>LRQ存储本地（也就是具体的p）的可运行goroutine， GRQ存储全局的可运行goroutine，这些goroutine还没有分配到具体的p。</p><h2 id="g0"><a href="#g0" class="headerlink" title="g0"></a>g0</h2><p>Go使用::GOMAXPROCS::环境变量来限制同时运行的OS线程数，这意味着Go必须在每个运行的线程上调度和管理Goroutine，该角色委托给了一个特殊的Goroutine，也就是::g0::，这是为每个OS线程创建的第一个Goroutine。</p><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*NK13K84tQhVx8DCPSXNG_g.png" alt="1*NK13K84tQhVx8DCPSXNG_g"></p><p>随后，g0将安排就绪的Goroutine在线程上运行。</p><h3 id="g0的职责"><a href="#g0的职责" class="headerlink" title="g0的职责"></a>g0的职责</h3><p>和普通的Goroutine相反，g0具有确定的和更大的堆栈。<br>它的职责包括：</p><ul><li>Goroutine创建，使用go关键字的时候，Go会将函数创建委托到g0，然后将创建的Goroutine放置到本地队列中</li><li>延迟功能分配</li><li>垃圾收集器操作，例如STW，扫描goroutine的堆栈以及一些标记和清除操作</li><li>堆栈增长，在需要时，Go会增加goroutine的大小，该操作也会通过g0来完成</li></ul><p>这种特殊的goroutine还涉及到许多其他操作（大分配，cgo等）。</p><h2 id="goroutine调度代价"><a href="#goroutine调度代价" class="headerlink" title="goroutine调度代价"></a>goroutine调度代价</h2><p>在Go中，一个goroutine的切换确实很轻量级，为了保存goroutine，它只需要完成两件事：</p><ul><li>goroutine在未调度之前停止的行，也就是保存当前要运行的行到PC寄存器中，稍后goroutine将在相同的地方恢复运行。</li><li>goroutine的堆栈，以便在再次运行时还原局部变量。</li></ul><p>假设有一段这样的代码：<br><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*TZobNBH4mKyaN8B_ru7tUA.png" alt="1*TZobNBH4mKyaN8B_ru7tUA"><br>消费者会打印从0到99的偶数。</p><p>首先，关注一下第一个goroutine（生产者），它将数字添加到channel的缓冲区中，当缓冲区被填满，当它再次发送数据时将会被阻塞。这个时候，Go将会切换到g0并且调度另外一个goroutine。</p><p>Go首先需要保存当前指令，以便在同一条指令中恢复goroutine，PC保存在goroutine的内部结构中，示例图如下。</p><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*ArVyzi31WBefg4RhhX5Pdw.png" alt="1*ArVyzi31WBefg4RhhX5Pdw"></p><p>指令以及地址可以使用以下命令查找:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool objdump</span><br></pre></td></tr></table></figure><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/9888D7A2-E02B-4A9C-8897-A81A760F7247.png" alt="9888D7A2-E02B-4A9C-8897-A81A760F7247"></p><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*E9HFNIw4ZhDirUh4dgWbsw.png" alt="1*E9HFNIw4ZhDirUh4dgWbsw"></p><p>在通道阻塞之前（runtime.chansend1），程序逐步执行指令，Go保存当前的PC寄存器为当前goroutine的一个内部属性.<br>在上图的例子中，Go通过内存地址<code>0x4268d0</code>保存PC寄存器，它在runtime和函数runtime.chansend1的内部。</p><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*i1SaUH3K7pjijTtW-O1TKw.png" alt="1*i1SaUH3K7pjijTtW-O1TKw"></p><p>接下来，当g0唤醒goroutine，它将恢复到相同的指令处，执行循环，将值传入通道。</p><h2 id="goroutine调度期间的堆栈管理"><a href="#goroutine调度期间的堆栈管理" class="headerlink" title="goroutine调度期间的堆栈管理"></a>goroutine调度期间的堆栈管理</h2><p>在被阻塞之前，正在运行的goroutine具有原来的堆栈，这个堆栈包含临时的内存，例如变量<code>i</code>：</p><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*8oa7ziZBpHZqKVihpQ3b8g.png" alt="1*8oa7ziZBpHZqKVihpQ3b8g"></p><p>然后，当它在channel上被阻塞的时候，goroutine以及堆栈都将被切换成g0以及g0的堆栈，一个更大的堆栈，如图。</p><p><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*I42dKDU2BV6kTwWMWiA1JQ.png" alt="1*I42dKDU2BV6kTwWMWiA1JQ"></p><p>在切换之前，这个堆栈将被保存起来用以goroutine再次运行时恢复。<br><img src= "/img/giphy.gif" data-lazy-src="http://www.midoriya.co/uPic/1*kmufEth8mfd7OLnkl9oC7Q.png" alt="1*kmufEth8mfd7OLnkl9oC7Q"></p><p>需要注意的是，一些架构例如arm，需要保存更多的寄存器：LR（连接寄存器）。</p><h2 id="goroutine切换总结"><a href="#goroutine切换总结" class="headerlink" title="goroutine切换总结"></a>goroutine切换总结</h2><p>以上图中的channel为例：</p><ul><li>当goroutine在channel上阻塞并且切换到了g0<ol><li>PC寄存器与堆栈指针一起保存到内部结构中</li><li>g0被设置为运行协程</li><li>g0的堆栈替换当前堆栈</li></ol></li><li>g0正在寻找新的goroutine运行</li><li>g0必须使用选定的goroutine进行切换：<ol><li>从内部结构中提取出PC寄存器和堆栈指针</li><li>程序跳转到从PC中提取出来的地址</li></ol></li></ul><h2 id="goroutine调度时机"><a href="#goroutine调度时机" class="headerlink" title="goroutine调度时机"></a>goroutine调度时机</h2><ul><li>使用关键字go<br>创建一个新的goroutine，Go Scheduler会考虑调度。<br>::新创建的Goroutine优先运行，并放置在LRQ的顶部::</li><li>GC<br>由于进行GC的goroutine也需要在M上运行，因此肯定会发生调度。</li><li>系统调用<br>当goroutine进行系统调用时，会阻塞M，所以它会被调度走，同时一个新的goroutine会被调度上来</li><li>内存同步访问<br>atomic，mutex，channel操作等会使goroutine阻塞，因此会被调度走。</li></ul><p>此外，需要注意，在调度期间，LRQ（本地队列）具有优先级。</p><h2 id="work-stealing"><a href="#work-stealing" class="headerlink" title="work stealing"></a>work stealing</h2><p>Go Scheduler的职责就是将所有处于Runnable的goroutines均匀分布到在p上运行的M。</p><p>当P的LRQ里没有goroutine时，它会先去全局队列里（GRQ）和网络轮询器中查看，如果这两者都为空，它将从其他P那里窃取goroutine。</p><p>TODO</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">Scheduling In Go : Part III - Concurrency</a><br><a href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a">Go: Goroutine, OS Thread and CPU Management - A Journey With Go - Medium</a><br><a href="https://medium.com/a-journey-with-go/go-g0-special-goroutine-8c778c6704d8">Go: g0, Special Goroutine - A Journey With Go - Medium</a></p>]]></content>
    
    
    <summary type="html">对Go调度器的学习总结，涉及系统调度、Goroutine模型</summary>
    
    
    
    <category term="Golang" scheme="https://www.midoriya.com/categories/Golang/"/>
    
    
    <category term="Scheduler" scheme="https://www.midoriya.com/tags/Scheduler/"/>
    
  </entry>
  
</feed>
